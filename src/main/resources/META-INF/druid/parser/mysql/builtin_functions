[Comparison Functions and Operators]
>:? > expr:Greater than operator
>=:? >= expr:Greater than or equal operator
<:? < expr:	Less than operator
<>:? <> expr:Not equal operator
!=:? != expr:Not equal operator
<=:? <= expr:Less than or equal operator
<=>:? <=> expr:NULL-safe equal to operator
= : ? = expr : Equal operator
BETWEEN ... AND ... :? BETWEEN min AND max :Whether a value is within a range of values
COALESCE:COALESCE(T v1, T v2, ...) :Return the first non-NULL argument
GREATEST:GREATEST(x1, x2, ...):Return the largest argument
IN : ? IN (value,...) :Whether a value is within a set of values
INTERVAL:INTERVAL():Return the index of the argument that is less than the first argument
IS	: ? IS boolean_value:Test a value against a boolean
IS NOT	: ? IS NOT boolean_value:Test a value against a boolean
IS NOT NULL	:? IS NOT NULL:NOT NULL value test
IS NULL	:? IS NULL :NULL value test
ISNULL() : ISNULL(?):Test whether the argument is NULL
LEAST()	: LEAST(value1,value2,...):Return the smallest argument
NOT BETWEEN ... AND ...	:? NOT BETWEEN min AND max:Whether a value is not within a range of values
NOT IN()	:? NOT IN (value,...):Whether a value is not within a set of values
[Logical Operators]
AND:? AND B:Logical AND
&&: ? && B:Logical AND
NOT:NOT ? :Negates value
!:! ? :Negates value
OR:? OR B :Logical OR
||:? || B :Logical OR
XOR: ? XOR B :Logical XOR
[Assignment Operators]
:= : @var1 := expr : Assign a value
= : @var1 = expr : Assign a value
[Flow Control Functions]
CASE_VALUE	:CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] [ELSE result] END:Case operator
CASE	:CASE WHEN condition THEN result [WHEN condition THEN result ...] [ELSE result] END:Case operator
IF()	:IF(expr1,expr2,expr3):If/else construct
IFNULL():IFNULL(expr1,expr2):	Null if/else construct
NULLIF():NULLIF(expr1,expr2):	Return NULL if expr1 = expr2
[Arithmetic Operators]
%:? % ?:Modulo operator
MOD:? MOD ?:Modulo operator
*:? * ? : Multiplication operator
+:? + ?: Addition operator
-:? - ? :Minus operator
-: - ? : Change the sign of the argument
/:? / ? : Division operator
DIV:? DIV ? :	Integer division
[Mathematical Functions]
ABS():ABS(?) :Return the absolute value
ACOS():ACOS(?) :Return the arc cosine
ASIN():ASIN(?): Return the arc sine
ATAN():ATAN(?): Return the arc tangent
ATAN2():ATAN2(?, ?): Return the arc tangent of the two arguments
CEIL():CEIL(?):Return the smallest integer value not less than the argument
CEILING():CEILING(?):Return the smallest integer value not less than the argument
CONV():CONV(?,from_base,to_base):Convert numbers between different number bases
COS():COS(?):Return the cosine
COT():COT(?):Return the cotangent
CRC32():CRC32(?):Compute a cyclic redundancy check value
DEGREES():DEGREES(?):Convert radians to degrees
EXP():EXP(?):Raise to the power of
FLOOR():FLOOR(?):Return the largest integer value not greater than the argument
LN():LN(?):Return the natural logarithm of the argument
LOG():LOG(?):Return the natural logarithm of the first argument
LOG10():LOG10(?):Return the base-10 logarithm of the argument
LOG2():LOG2(?):Return the base-2 logarithm of the argument
MOD():MOD(N,M):Return the remainder
PI():PI():Return the value of pi
POW():POW(?,n)         :Return the argument raised to the specified power
POWER():POWER(?,n)     :Return the argument raised to the specified power
RADIANS():RADIANS(?)   :Return argument converted to radians
RAND():RAND(seed)      :Return a random floating-point value
ROUND():ROUND(?)       :Round the argument
SIGN():SIGN(?)         :Return the sign of the argument
SIN():SIN(?)           :Return the sine of the argument
SQRT():SQRT(?)         :Return the square root of the argument
TAN():TAN(?)           :Return the tangent of the argument
TRUNCATE:TRUNCATE(X,D) :Truncate to specified number of decimal places
[Date and Time Functions]
ADDDATE()			:ADDDATE(?,days) :Add time values (intervals) to a date value
ADDDATE()			:ADDDATE(?,INTERVAL expr unit) :Add time values (intervals) to a date value
ADDTIME()			:ADDTIME(expr1,expr2) :Add time
CONVERT_TZ()		:CONVERT_TZ(?,from_tz,to_tz) :Convert from one time zone to another
CURDATE()			:CURDATE() :Return the current date
CURRENT_DATE()		:CURRENT_DATE() :Synonyms for CURDATE()
CURRENT_DATE		:CURRENT_DATE :Synonyms for CURDATE()
CURRENT_TIME()		:CURRENT_TIME(([fsp])) :Synonyms for CURTIME()
CURRENT_TIME		:CURRENT_TIME :Synonyms for CURTIME()
CURRENT_TIMESTAMP()	:CURRENT_TIMESTAMP(([fsp])) :Synonyms for NOW()
CURRENT_TIMESTAMP	:CURRENT_TIMESTAMP :Synonyms for NOW()
CURTIME()			:CURTIME([fsp]) :Return the current time
DATE()				:DATE(?) :Extract the date part of a date or datetime expression
DATE_ADD()			:DATE_ADD(?,INTERVAL expr unit) :Add time values (intervals) to a date value
DATE_FORMAT()		:DATE_FORMAT(?,format) :Format date as specified
DATE_SUB()			:DATE_SUB(date,INTERVAL expr unit) :Subtract a time value (interval) from a date
DATEDIFF()			:DATEDIFF(expr1,expr2) :Subtract two dates
DAY()				:DAY(?) :Synonym for DAYOFMONTH()
DAYNAME()			:DAYNAME(?) :Return the name of the weekday
DAYOFMONTH()		:DAYOFMONTH(?) :Return the day of the month (0-31)
DAYOFWEEK()			:DAYOFWEEK(?) :Return the weekday index of the argument
DAYOFYEAR()			:DAYOFYEAR(?) :Return the day of the year (1-366)
EXTRACT()			:EXTRACT(unit FROM ?) :Extract part of a date
FROM_DAYS()			:FROM_DAYS(?) :Convert a day number to a date
FROM_UNIXTIME()		:FROM_UNIXTIME(?[,format]) :Format Unix timestamp as a date
GET_FORMAT()		:GET_FORMAT({DATE|TIME|DATETIME}, {'EUR'|'USA'|'JIS'|'ISO'|'INTERNAL'}) :Return a date format string
HOUR()				:HOUR(?) :Extract the hour
LAST_DAY			:LAST_DAY(?) :Return the last day of the month for the argument
LOCALTIME()			:LOCALTIME([fsp]) :Synonym for NOW()
LOCALTIME			:LOCALTIME :Synonym for NOW()
LOCALTIMESTAMP		:LOCALTIMESTAMP :Synonym for NOW()
LOCALTIMESTAMP()	:LOCALTIMESTAMP([fsp]) :Synonym for NOW()
MAKEDATE()			:MAKEDATE(year,dayofyear) :Create a date from the year and day of year
MAKETIME()			:MAKETIME(hour,minute,second) :Create time from hour, minute, second
MICROSECOND()		:MICROSECOND(?) :Return the microseconds from argument
MINUTE()			:MINUTE(?) :Return the minute from the argument
MONTH()				:MONTH(?) :Return the month from the date passed
MONTHNAME()			:MONTHNAME(?) :Return the name of the month
NOW()				:NOW([fsp]) :Return the current date and time
PERIOD_ADD()		:PERIOD_ADD(P,N) :Add a period to a year-month
PERIOD_DIFF()		:PERIOD_DIFF(P1,P2) :Return the number of months between periods
QUARTER()			:QUARTER(?) :Return the quarter from a date argument
SEC_TO_TIME()		:SEC_TO_TIME(?) :Converts seconds to 'hh:mm:ss' format
SECOND()			:SECOND(?) :Return the second (0-59)
STR_TO_DATE()		:STR_TO_DATE(?,format) :Convert a string to a date
SUBDATE()			:SUBDATE(?,INTERVAL expr unit), SUBDATE(expr,days) :Synonym for DATE_SUB() when invoked with three arguments
SUBDATE()			:SUBDATE(?,days) :Synonym for DATE_SUB() when invoked with three arguments
SUBTIME()			:SUBTIME(expr1,expr2) :Subtract times
SYSDATE()			:SYSDATE([fsp]) :Return the time at which the function executes
TIME()				:TIME(?) :Extract the time portion of the expression passed
TIME_FORMAT()		:TIME_FORMAT(?,format) :Format as time
TIME_TO_SEC()		:TIME_TO_SEC(?) :Return the argument converted to seconds
TIMEDIFF()			:TIMEDIFF(expr1,expr2) :Subtract time
TIMESTAMP()			:TIMESTAMP(expr) :With a single argument, this function returns the date or datetime expression; with two arguments, the sum of the arguments
TIMESTAMP()			:TIMESTAMP(expr1,expr2) :With a single argument, this function returns the date or datetime expression; with two arguments, the sum of the arguments
TIMESTAMPADD()		:TIMESTAMPADD(unit,interval,?) :Add an interval to a datetime expression
TIMESTAMPDIFF()		:TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2) :Subtract an interval from a datetime expression
TO_DAYS()			:TO_DAYS(?) :Return the date argument converted to days
TO_SECONDS()		:TO_SECONDS(?) :Return the date or datetime argument converted to seconds since Year 0
UNIX_TIMESTAMP()	:UNIX_TIMESTAMP([date]) :Return a Unix timestamp
UTC_DATE			:UTC_DATE :Return the current UTC date
UTC_DATE()			:UTC_DATE() :Return the current UTC date
UTC_TIME()			:UTC_TIME([fsp]) :Return the current UTC time
UTC_TIME			:UTC_TIME    :Return the current UTC time
UTC_TIMESTAMP()		:UTC_TIMESTAMP([fsp]) :Return the current UTC date and time
UTC_TIMESTAMP		:UTC_TIMESTAMP :Return the current UTC date and time
WEEK()				:WEEK(?[,mode]) :Return the week number
WEEKDAY()			:WEEKDAY(?) :Return the weekday index
WEEKOFYEAR()		:WEEKOFYEAR(?) :Return the calendar week of the date (1-53)
YEAR()				:YEAR(?) :Return the year
YEARWEEK()			:YEARWEEK(?) :Return the year and week
YEARWEEK()			:YEARWEEK(?,mode) :Return the year and week
[String Comparison Functions and Operators]
ASCII()				: ASCII(?)    :Return numeric value of left-most character
BIN()				: BIN(?)                        :Return a string containing binary representation of a number
BIT_LENGTH()		: BIT_LENGTH(str)                      :Return length of argument in bits
CHAR()				: CHAR(N,... [USING charset_name])                :Return the character for each integer passed
CHAR_LENGTH()		: CHAR_LENGTH(?)                     :Return number of characters in argument
CHARACTER_LENGTH()	: CHARACTER_LENGTH(?)                 :Synonym for CHAR_LENGTH()
CONCAT()			: CONCAT(str1,str2,...)            :Return concatenated string
CONCAT_WS()			: CONCAT_WS(separator,str1,str2,...)     :Return concatenate with separator
ELT()				: ELT(N,str1,str2,str3,...)         :Return string at index number
EXPORT_SET()		: EXPORT_SET(bits,on,off[,separator[,number_of_bits]])       :Return a string such that for every bit set in the value bits, you get an on string and for every unset bit, you get an off string
FIELD()				: FIELD(?,str1,str2,str3,...)     :Index (position) of first argument in subsequent arguments
FIND_IN_SET()		: FIND_IN_SET(?,strlist)                               :Index (position) of first argument within second argument
FORMAT()			: FORMAT(?,D[,locale])            :Return a number formatted to specified number of decimal places
FROM_BASE64()		: FROM_BASE64(?)                  :Decode base64 encoded string and return result
HEX()				: HEX(?)                 :Hexadecimal representation of decimal or string value
INSERT()			: INSERT(str,pos,len,newstr)                               :Insert substring at specified position up to specified number of characters
INSTR()				: INSTR(str,substr)                               :Return the index of the first occurrence of substring
LCASE()				: LCASE(?)                    :Synonym for LOWER()
LEFT()				: LEFT(?,len)                               :Return the leftmost number of characters as specified
LENGTH()			: LENGTH(?)                               :Return the length of a string in bytes
LOAD_FILE()			: LOAD_FILE(file_name)                               :Load the named file
LOCATE()			: LOCATE(substr,str[,pos])                               :Return the position of the first occurrence of substring
LOWER()				: LOWER(?)                          :Return the argument in lowercase
LPAD()				: LPAD(?,len,padstr)             :Return the string argument, left-padded with the specified string
MAKE_SET()			: LTRIM(?)                     :Return a set of comma-separated strings that have the corresponding bit in bits set
MATCH()				: MAKE_SET(bits,str1,str2,...)                   :Perform full-text search
MID()				: MID(?,pos,len)                               :Return a substring starting from the specified position
OCT()				: OCT(?)                         :Return a string containing octal representation of a number
OCTET_LENGTH()		: OCTET_LENGTH(?)                      :Synonym for LENGTH()
ORD()				: ORD(?)                      :Return character code for leftmost character of the argument
POSITION()			: POSITION(substr IN str)                       :Synonym for LOCATE()
QUOTE()				: QUOTE(?)                               :Escape the argument for use in an SQL statement
REPEAT()			: REPEAT(?,count)                         :Repeat a string the specified number of times
REPLACE()			: REPLACE(?,from_str,to_str)               :Replace occurrences of a specified string
REVERSE()			: REVERSE(?)        :Reverse the characters in a string
RIGHT()				: RIGHT(?,len)                     :Return the specified rightmost number of characters
RPAD()				: RPAD(?,len,padstr)                                :Append string the specified number of times
RTRIM()				: RTRIM(?)                               :Remove trailing spaces
SOUNDEX()			: SOUNDEX(?)                               :Return a soundex string
SOUNDS LIKE			: ? SOUNDS LIKE ?                               :Compare sounds
SPACE()				: SPACE(?)                               :Return a string of the specified number of spaces
SUBSTR()			: SUBSTR(?,pos[,len])                              :Return the substring as specified
SUBSTRING()			: SUBSTRING(?,pos[,len])                               :Return the substring as specified
SUBSTRING_INDEX()	: SUBSTRING_INDEX(?,delim,count)                               :Return a substring from a string before the specified number of occurrences of the delimiter
TO_BASE64()			: TO_BASE64(?)                               :Return the argument converted to a base-64 string
TRIM()				: TRIM([{BOTH | LEADING | TRAILING} [remstr] FROM] ?)                              :Remove leading and trailing spaces
TRIM()				: TRIM([remstr FROM] ?)                               :Remove leading and trailing spaces
UCASE()				: UCASE(?)                               :Synonym for UPPER()
UNHEX()				: UNHEX(?)                               :Return a string containing hex representation of a number
UPPER()				: UPPER(?)                               :Convert to uppercase
WEIGHT_STRING()		: WEIGHT_STRING(? [AS {CHAR|BINARY}(N)] [flags])                               :Return the weight string for a string
[String Comparison Functions and Operators]
LIKE	            : ? LIKE pat [ESCAPE 'escape_char']      :Simple pattern matching
NOT LIKE	        : ? NOT LIKE pat [ESCAPE 'escape_char']      :Negation of simple pattern matching
STRCMP()	        : STRCMP(expr1,expr2)      :Compare two strings
[Regular Expressions]
NOT REGEXP			: ? NOT REGEXP pat     :Negation of REGEXP
REGEXP				: ? REGEXP pat                               :Whether string matches regular expression
REGEXP_INSTR()		: REGEXP_INSTR(?, pat[, pos[, occurrence[, return_option[, match_type]]]])                               :Starting index of substring matching regular expression
REGEXP_LIKE()		: REGEXP_LIKE(?, pat[, match_type])                               :Whether string matches regular expression
REGEXP_REPLACE()	: REGEXP_REPLACE(?, pat, repl[, pos[, occurrence[, match_type]]])                               :Replace substrings matching regular expression
REGEXP_SUBSTR()		: REGEXP_SUBSTR(?, pat[, pos[, occurrence[, match_type]]])                               :Return substring matching regular expression
RLIKE				: ? RLIKE pat                 :Whether string matches regular expression
NOT RLIKE		    : ? NOT RLIKE pat                 :Whether string NOT matches regular expression
[Full-Text Search Functions]
MATCH:  MATCH (?,...) AGAINST (expr [search_modifier]) : Full-Text Search Functions
[Cast Functions and Operators]
BINARY		:BINARY ?                           :Cast a string to a binary string
CAST()		:CAST(? AS type [ARRAY])            :Cast a value as a certain type
CONVERT()	:CONVERT(? USING transcoding_name)  :Cast a value as a certain type
[XML Functions]
ExtractValue()  :ExtractValue(xml_frag, xpath_expr)         :Extract a value from an XML string using XPath notation
UpdateXML()     :UpdateXML(xml_target, xpath_expr, new_xml)	:Return replaced XML fragment
[Bit Functions and Operators]
&	            :&              :Bitwise AND
>>	            :>>             :  Right shift
<<	            :<<             :  Left shift
^	            :^              :Bitwise XOR
BIT_COUNT()	    :BIT_COUNT(N)   :Return the number of bits that are set
|	            :|              :Bitwise OR
~	            :~              :Bitwise inversion
[Encryption and Compression Functions]
AES_DECRYPT()	        		:AES_DECRYPT(?,key_str[,init_vector][,kdf_name][,salt][,info | iterations]) :Decrypt using AES
AES_ENCRYPT()	        		:AES_ENCRYPT(?,key_str[,init_vector][,kdf_name][,salt][,info | iterations]) :Encrypt using AES
COMPRESS()	            		:COMPRESS(?)    :Return result as a binary string
MD5()	                		:MD5(?)         :Calculate MD5 checksum
RANDOM_BYTES()	        		:RANDOM_BYTES(?):Return a random byte vector
SHA1()	        		        :SHA1(?)        :Calculate an SHA-1 160-bit checksum
SHA()	        		        :SHA(?)         :Calculate an SHA-1 160-bit checksum
SHA2()	                		:SHA2(?, hash_length)               :Calculate an SHA-2 checksum
STATEMENT_DIGEST()	    		:STATEMENT_DIGEST(statement)        :Compute statement digest hash value
STATEMENT_DIGEST_TEXT()			:STATEMENT_DIGEST_TEXT(statement)   :Compute normalized statement digest
UNCOMPRESS()	        		:UNCOMPRESS(?)                      :Uncompress a string compressed
UNCOMPRESSED_LENGTH()			:UNCOMPRESSED_LENGTH(?)             :Return the length of a string before compression
VALIDATE_PASSWORD_STRENGTH()	:VALIDATE_PASSWORD_STRENGTH(?)      :Determine strength of password
[Locking Functions]
GET_LOCK()	        :GET_LOCK(?,timeout)    :Get a named lock
IS_FREE_LOCK()	    :IS_FREE_LOCK(?)        :Whether the named lock is free
IS_USED_LOCK()	    :IS_USED_LOCK(?)        :Whether the named lock is in use; return connection identifier if true
RELEASE_ALL_LOCKS()	:RELEASE_ALL_LOCKS()    :Release all current named locks
RELEASE_LOCK()	    :RELEASE_LOCK(?)        :Release the named lock
[Information Functions]
BENCHMARK()	    :BENCHMARK(count,?) :Repeatedly execute an expression
CHARSET()	    :CHARSET(?)         :Return the character set of the argument
COERCIBILITY()	:COERCIBILITY(?)    :Return the collation coercibility value of the string argument
COLLATION()	    :COLLATION(?)       :Return the collation of the string argument
CONNECTION_ID()	:CONNECTION_ID()    :Return the connection ID (thread ID) for the connection
CURRENT_ROLE()	:CURRENT_ROLE()     :Return the current active roles
CURRENT_USER()  :CURRENT_USER()     :The authenticated user name and host name
CURRENT_USER	:CURRENT_USER       :The authenticated user name and host name
DATABASE()	    :DATABASE()         :Return the default (current) database name
FOUND_ROWS()	:FOUND_ROWS()       :For a SELECT with a LIMIT clause, the number of rows that would be returned were there no LIMIT clause
ICU_VERSION()	:ICU_VERSION()      :ICU library version
LAST_INSERT_ID():LAST_INSERT_ID([expr]) :Value of the AUTOINCREMENT column for the last INSERT
ROLES_GRAPHML()	:ROLES_GRAPHML()        :Return a GraphML document representing memory role subgraphs
ROW_COUNT()	    :ROW_COUNT()        :The number of rows updated
SCHEMA()	    :SCHEMA()           :Synonym for DATABASE()
SESSION_USER()	:SESSION_USER()     :Synonym for USER()
SYSTEM_USER()	:SYSTEM_USER()      :Synonym for USER()
USER()	        :USER()	            :The user name and host name provided by the client
VERSION()	    :VERSION()          :Return a string that indicates the MySQL server version



FORMAT:FORMAT( ?, D)
&:? & expr:Bitwise AND
>>:? >> N:Right shift
<<:? << N:Right shift



->:column->path:Return value from JSON column after evaluating path; equivalent to JSON_EXTRACT().
->> : column->>path : Return value from JSON column after evaluating path and unquoting the result; equivalent to JSON_UNQUOTE(JSON_EXTRACT()).


^:? ^ expr :Bitwise XOR


ADDTIME:ADDTIME(expr1,expr2): Add time
AES_DECRYPT()

[BitOperators]
!:!?


|:? | expr
~:? ~ expr
<<:? << N

[]
json_overlaps:
get_dd_column_privileges:
case:
get_dd_index_sub_part_length:
get_dd_create_options:
[AggregateFunctions]
count(distinct):COUNT(DISTINCT ?)
group_concat:GROUP_CONCAT(?)
COUNT:COUNT(?)
stddev_samp:STDDEV_SAMP(?)
MAX:MAX([DISTINCT] ?)
STDDEV:STDDEV(?)
std:STD(?)
SUM:SUM([DISTINCT] ?)
MIN:MIN([DISTINCT] ?)
bit_and:bit_and(?)
AVG:AVG(?)
var_pop:VAR_POP(?)
grouping:GROUPING(? ...)
stddev_pop:STDDEV_POP(?)
json_arrayagg:JSON_ARRAYAGG(?)
bit_or:bit_or(?)
var_samp:VAR_SAMP(?)
json_objectagg:JSON_OBJECTAGG(key, value)
variance:VARIANCE(?)
bit_xor:bit_xor(?)
[FlowControlFunctions]
IFNULL:IFNULL(v1,v2)
if:if(boolean testCondition, T valueTrue, T valueFalseOrNull)
[NULLRelatedFunctions]
nullif:nullif( a, b )
[WindowFunction]
rank:RANK() over(partition by ?  order by ? desc)
lag:LAG(? [, N[, default]]) over(partition by ?  order by ? desc)
first_value:first_value(?) over(partition by ?  order by ? desc)
ntile:NTILE(N) over_clause
row_number:row_number() over(partition by ?  order by ? desc)
percent_rank:percent_rank() over(partition by ?  order by ? desc)
last_value:last_value(?) over(partition by ?  order by ? desc)
dense_rank:dense_rank() over(partition by ?  order by ? desc)
cume_dist:cume_dist() over(partition by ?  order by ? desc)
lead:LEAD(? [, N[, default]]) over(partition by ?  order by ? desc)
nth_value:NTH_VALUE(?, N) over_clause
[ComparisonOperators]
least:least(x1, x2, ...)
SOUNDS LIKE:expr1 SOUNDS LIKE expr2

strcmp:STRCMP(expr1,expr2)
[RegularExpressions]
regexp_substr:REGEXP_SUBSTR(?, pat[, pos[, occurrence[, match_type]]])
REGEXP:? REGEXP pat
regexp_replace:REGEXP_REPLACE(?, pat, repl[, pos[, occurrence[, match_type]]])
REGEXP_INSTR:REGEXP_INSTR(?, pat[, pos[, occurrence[, return_option[, match_type]]]])
NOT REGEXP:? NOT REGEXP pat
regexp_like:REGEXP_LIKE(expr, pat[, match_type])
[StringFunction]
character_length:CHARACTER_LENGTH(?)
quote:QUOTE(?)
trim:TRIM(?),
concat:CONCAT(str1,str2,...)
LEFT:LEFT(?,len)
RIGHT:RIGHT(?,2)
lpad:LPAD(?,len,padstr)
ltrim:LTRIM(?)
elt:ELT(N,str1,str2,str3,...)
length:LENGTH(?)
make_set:MAKE_SET(bits,str1,str2,...)
bin:BIN(?)
from_base64:from_base64(?)
lower:LOWER(?)
export_set:EXPORT_SET(bits,on,off[,separator[,number_of_bits]])
substr:SUBSTR(?,pos[,len])
field:FIELD(str,str1,str2,str3,...)
concat_ws:CONCAT_WS(separator,str1,str2,...)
soundex:SOUNDEX(?)
POSITION:position(substring in str)
locate:LOCATE(substr,str[,pos])
substring:SUBSTRING(?,pos[,len])
repeat:REPEAT(?,count)
rtrim:RTRIM(?)
upper:UPPER(?)
CHAR_LENGTH:CHAR_LENGTH(?)
mid:MID(?,pos,len)
weight_string:WEIGHT_STRING(? [AS {CHAR|BINARY}(N)] [flags])
rpad:RPAD(?,len,padstr)
ascii:ASCII(?)
find_in_set:FIND_IN_SET(str,strlist)
octet_length:OCTET_LENGTH(?)
instr:INSTR(str,substr)
reverse:REVERSE(?)
CHAR:CHAR(N,... [USING charset_name])
replace:REPLACE(str,from_str,to_str)
space:SPACE(N)
substring_index:SUBSTRING_INDEX(?,delim,count)
FORMAT:FORMAT( value, format)
ucase:UCASE(?)
lcase:LCASE(?)
INSERT:INSERT(?,POS,SIZE,replaceExpr)
BIT_LENGTH:BIT_LENGTH(?)
load_file:LOAD_FILE(file_name)
[ConditionalOperators]
member of:? MEMBER OF(json_array)
[BinaryOperator]
~:~()
[BitFunctions]
BIT_COUNT:BIT_COUNT(?)
[XMLFunctions]
updatexml:UpdateXML(xml_target, xpath_expr, new_xml)
extractvalue:ExtractValue(xml_frag, xpath_expr)
[RelationalOperator]
isnull:? IS NULL
IS:? IS
IS NOT NULL:? IS NOT NULL
RLIKE:? RLIKE pat
NOT LIKE:? NOT LIKE pat
IS NOT:? IS NOT
LIKE:? LIKE pat
[ConcatenationOperator]
||:? || ?
[PerformanceSchemaFunctions]
format_bytes:FORMAT_BYTES(count)
ps_current_thread_id:ps_current_thread_id()
ps_thread_id:PS_THREAD_ID(connection_id)
format_pico_time:FORMAT_PICO_TIME(time_val)

[MiscellaneousFunctions]
mbrtouches:MBRTouches(g1, g2)
st_srid:st_srid(?)
is_ipv4_compat:is_ipv4_compat(?)
normalize_statement:normalize_statement(?)
uuid_short:uuid_short()
mbrcovers:MBRCovers(g1, g2)
read_firewall_users:read_firewall_users(user, mode)
st_union:ST_Union(g1, g2)
sleep:SLEEP(duration)
st_pointatdistance:st_pointatdistance()
st_mpointfromtext:st_mpointfromtext()
st_collect:st_collect()
inet6_aton:inet6_aton()
st_isclosed:st_isclosed()
mbrcoveredby:mbrcoveredby()
st_numgeometries:st_numgeometries()
~:~()
st_geomcollfromwkb:st_geomcollfromwkb()
st_asbinary:st_asbinary()
st_pointfromgeohash:st_pointfromgeohash()
master_pos_wait:MASTER_POS_WAIT(log_name,log_pos[,timeout][,channel])
st_endpoint:st_endpoint()
st_symdifference:st_symdifference()
multipoint:multipoint()
st_envelope:st_envelope()
st_touches:st_touches()
mbrcontains:mbrcontains()
mbrwithin:mbrwithin()
st_isvalid:st_isvalid()
st_longfromgeohash:st_longfromgeohash()
st_difference:st_difference()
current_role:current_role()
st_issimple:st_issimple()
bin_to_uuid:BIN_TO_UUID(?, swap_flag)
set_firewall_mode:set_firewall_mode(user, mode)
multipolygon:multipolygon()
st_linefromtext:st_linefromtext()
not between ... and ...:? NOT BETWEEN min AND max
charset:charset()
st_makeenvelope:st_makeenvelope()
st_transform:st_transform()
st_buffer_strategy:st_buffer_strategy()
st_intersection:st_intersection()
st_area:st_area()
polygon:polygon()
read_firewall_whitelist:read_firewall_whitelist(user, rule)
st_validate:st_validate()
st_linefromwkb:st_linefromwkb()
row_count:row_count()
uuid_to_bin:UUID_TO_BIN(?, swap_flag)
mbrdisjoint:mbrdisjoint()
st_interiorringn:st_interiorringn()
st_contains:st_contains()
is_uuid:is_uuid(?)
st_astext:st_astext()
is_ipv4_mapped:is_ipv4_mapped(?)
st_overlaps:st_overlaps()
mbrequals:mbrequals()
st_asgeojson:st_asgeojson()
st_hausdorffdistance:st_hausdorffdistance()
st_numpoints:st_numpoints()
mbroverlaps:mbroverlaps()
st_polyfromtext:st_polyfromtext()
st_pointfromwkb:st_pointfromwkb()
st_geomfromtext:st_geomfromtext()
st_mpointfromwkb:st_mpointfromwkb()
st_mpolyfromtext:st_mpolyfromtext()
st_x:st_x()
st_y:st_y()
st_geometrytype:st_geometrytype()
st_polyfromwkb:st_polyfromwkb()
st_distance_sphere:st_distance_sphere()
default:DEFAULT(?)
name_const:NAME_CONST(name,value)
st_swapxy:st_swapxy()
st_startpoint:st_startpoint()
st_isempty:st_isempty()
linestring:linestring()
st_lineinterpolatepoints:st_lineinterpolatepoints()
st_distance:st_distance()
st_longitude:st_longitude()
coercibility:coercibility()
source_pos_wait:SOURCE_POS_WAIT(log_name,log_pos[,timeout][,channel])
st_geomfromgeojson:st_geomfromgeojson()
st_length:st_length()
st_disjoint:st_disjoint()
st_frechetdistance:st_frechetdistance()
st_exteriorring:st_exteriorring()
st_pointfromtext:st_pointfromtext()
ord:ORD(?)
st_convexhull:st_convexhull()
any_value:any_value(?)
st_latitude:st_latitude()
inet_aton:inet_aton(?)
multilinestring:multilinestring()
benchmark:benchmark()
geometrycollection:geometrycollection()
st_centroid:st_centroid()
st_lineinterpolatepoint:st_lineinterpolatepoint()
st_within:st_within()
geomcollection:geomcollection()
inet6_ntoa:INET6_NTOA(?)
mbrintersects:mbrintersects()
st_dimension:st_dimension()
st_crosses:st_crosses()
st_geomcollfromtext:st_geomcollfromtext()
st_mlinefromtext:st_mlinefromtext()
st_mpolyfromwkb:st_mpolyfromwkb()
st_geometryn:st_geometryn()
st_simplify:st_simplify()
st_geomfromwkb:st_geomfromwkb()
uuid:uuid()
collation:collation()
st_numinteriorring:st_numinteriorring()
st_equals:st_equals()
st_latfromgeohash:st_latfromgeohash()
found_rows:found_rows()
mysql_firewall_flush_status:mysql_firewall_flush_status()
values:values(?)
is_ipv6:is_ipv6(?)
is_ipv4:is_ipv4(?)
point:point()
st_buffer:st_buffer()
st_geohash:st_geohash()
st_pointn:st_pointn()
match:match()
inet_ntoa:inet_ntoa(?)
st_mlinefromwkb:st_mlinefromwkb()
[CompressionFunctions]
uncompressed_length:uncompressed_length()
compress:compress(?)
uncompress:uncompress(?)
[LogicalOperator]

not in:? NOT IN (value,...|subquery)
[CollectionFunction]
st_intersects:st_intersects(A, B)
[EncodingAndDecodingFunctions]
encode:ENCODE(?)
decode:DECODE(?)
[ConditionalFunction]
isnull:ISNOTNULL(?)
[ArithmeticOperator]
%:? % ?


[ENCRYPT_DECRYPT]


asymmetric_verify:asymmetric_verify(algorithm, ?, sig_str, pub_key_str, digest_type)
create_asymmetric_pub_key:create_asymmetric_pub_key(algorithm, priv_key_str)
OLD_PASSWORD:OLD_PASSWORD(?)
sha:SHA(?)
sha1:SHA1(?)
sha2:SHA2(?)
md5:MD5(?)
asymmetric_sign:asymmetric_sign(algorithm, ?, priv_key_str, digest_type)
asymmetric_derive:asymmetric_derive(pub_key_str, priv_key_str)
validate_password_strength:validate_password_strength()
PASSWORD:PASSWORD(?)
ENCRYPT:ENCRYPT(?)
asymmetric_decrypt:asymmetric_decrypt(algorithm, ?, priv_key_str)
create_digest:create_digest(digest_type, ?)
DES_ENCRYPT:DES_ENCRYPT(?)
statement_digest_text:STATEMENT_DIGEST_TEXT(statement)
create_asymmetric_priv_key:create_asymmetric_priv_key(algorithm, {key_len|dh_secret})
create_dh_parameters:create_dh_parameters(key_len)
random_bytes:RANDOM_BYTES(len)
statement_digest:STATEMENT_DIGEST(statement)
asymmetric_encrypt:asymmetric_encrypt(algorithm, ?, pub_key_str)
DES_DECRYPT:DES_DECRYPT(?)
[ConversionFunctions]
to_base64:to_base64(?)
CONVERT:CONVERT(?,type)
oct:OCT(?)
BINARY:BINARY ?
AS BINARY:? AS BINARY
cast:CAST(? AS type)
USING BINARY:? USING BINARY
hex:HEX(?)
unhex:UNHEX(?)
CHAR:CHAR(?)
DATE:DATE(?)
[JSONFunctions]
json_value:JSON_VALUE(json_doc, path)
json_schema_valid:JSON_SCHEMA_VALID(schema,document)
json_unquote:JSON_UNQUOTE(?)
json_pretty:json_pretty(?)
json_schema_validation_report:JSON_SCHEMA_VALIDATION_REPORT(schema,document)
json_merge:JSON_MERGE(?, ...)
json_array_insert:JSON_ARRAY_INSERT(?, path, val[, path, val] ...)
json_length:JSON_LENGTH(?[, path])
json_keys:JSON_KEYS(?[, path])
json_storage_free:json_storage_free(?)
json_array:JSON_ARRAY([val, ...])
json_depth:json_depth(?)
json_remove:JSON_REMOVE(?, path ...)
json_extract:JSON_EXTRACT(?, path[, path] ...)
json_valid:JSON_VALID(?)
json_merge_patch:JSON_MERGE_PATCH(?, ...)
json_set:JSON_SET(?, path, val[, path, val] ...)
json_contains:JSON_CONTAINS(?, candidate[, path])
json_table:JSON_TABLE(?, path COLUMNS (column_list) [AS] alias)
json_object:JSON_OBJECT([key, val[, key, val] ...])
json_replace:JSON_REPLACE(?, path, val[, path, val] ...)
json_insert:JSON_INSERT(?, path, val[, path, val] ...)
json_quote:json_quote(?)
json_type:JSON_TYPE(?)
json_storage_size:json_storage_size(?)
json_search:JSON_SEARCH(?, one_or_all, search_str[, escape_char[, path] ...])
json_contains_path:JSON_CONTAINS_PATH(?, one_or_all, path[, path] ...)
json_objectagg:JSON_OVERLAPS(json_doc1, json_doc2)
json_array_append:JSON_ARRAY_APPEND(?, path, val[, path, val] ...)
json_merge_preserve:JSON_MERGE_PRESERVE(json_doc, ...)
[LockFunctions]
RELEASE_LOCK:RELEASE_LOCK(?)
IS_USED_LOCK:IS_USED_LOCK(?)
get_lock:GET_LOCK(?,timeout)
release_all_locks:RELEASE_ALL_LOCKS()
is_free_lock:IS_FREE_LOCK(?)
[GlobalTransactionIdentifiers]
gtid_subset:GTID_SUBSET(set1,set2)
gtid_subtract:GTID_SUBTRACT(set1,set2)
wait_until_sql_thread_after_gtids:WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS(gtid_set[, timeout][,channel])
wait_for_executed_gtid_set:WAIT_FOR_EXECUTED_GTID_SET(gtid_set[, timeout])
[DatetimeFunctions]
year:YEAR(?)
utc_time:utc_time()
to_seconds:to_seconds(?)

TIMEDIFF:TIMEDIFF(?,?)
date_format:DATE_FORMAT(?,format)
quarter:QUARTER(?)
LOCALTIME:LOCALTIME()
month:MONTH(?)
TO_DAYS:TO_DAYS(?)
date_sub:DATE_SUB(date,INTERVAL expr unit)
STR_TO_DATE:STR_TO_DATE(?,format)
MAKEDATE:MAKEDATE(year, day-of-year)
LOCALTIMESTAMP:LOCALTIMESTAMP()
timestampadd:TIMESTAMPADD(unit,interval,?)
TIME_FORMAT:TIME_FORMAT(?,format)
current_date:CURRENT_DATE()
SUBDATE:SUBDATE(?,n)
convert_tz:CONVERT_TZ(?,from_tz,to_tz)
get_format:GET_FORMAT(?, {'EUR'|'USA'|'JIS'|'ISO'|'INTERNAL'})
utc_timestamp:UTC_TIMESTAMP()

PERIOD_DIFF:PERIOD_DIFF(period, number)
second:SECOND(?)
SUBTIME:SUBTIME(expr1,expr2)
SEC_TO_TIME:SEC_TO_TIME(?)
hour:HOUR(?)
current_timestamp:CURRENT_TIMESTAMP()
minute:MINUTE(?)
YEARWEEK:YEARWEEK(?)
utc_date:UTC_DATE()
WEEKDAY:WEEKDAY(?)
curtime:CURTIME()
dayofyear:DAYOFYEAR(?)
MICROSECOND:MICROSECOND(?)
datediff:DATEDIFF(expr1,expr2)
TIME_TO_SEC:TIME_TO_SEC(?)
current_time:CURRENT_TIME()
TIMESTAMP:TIMESTAMP(?)
date_add:DATE_ADD(date,INTERVAL expr unit)
DAYNAME:DAYNAME(?)
extract:EXTRACT(unit FROM ?)
from_unixtime:FROM_UNIXTIME(?[,format])
curdate:CURDATE()
now:NOW()
TIME:TIME(?)
from_days:from_days(N)
unix_timestamp:UNIX_TIMESTAMP([date])
last_day:LAST_DAY(?)
date:DATE(?)
SYSDATE:SYSDATE()
MONTHNAME:MONTHNAME(?)
day:DAY(?)
MAKETIME:MAKETIME(hour, minute, second)
WEEK:WEEK(?)
PERIOD_ADD:PERIOD_ADD(period, number)
dayofmonth:DAYOFMONTH(?)
TIMESTAMPDIFF:TIMESTAMPDIFF(unit,?,?)
ROUND:ROUND(?[,fmt])
DAYOFWEEK:DAYOFWEEK(?)
weekofyear:WEEKOFYEAR(?)
[InformationFunctions]
LAST_INSERT_ID:LAST_INSERT_ID()
VERSION:VERSION('parameter')
SCHEMA:SCHEMA()
SESSION_USER:SESSION_USER ()
CHARSET:CHARSET(?)
CURRENT_USER:CURRENT_USER()
ROW_COUNT:ROW_COUNT()
icu_version:ICU_VERSION()
roles_graphml:ROLES_GRAPHML()
COERCIBILITY:COERCIBILITY(?)
BENCHMARK:BENCHMARK(count,?)
SYSTEM_USER:SYSTEM_USER()
CONNECTION_ID:CONNECTION_ID()
COLLATION:COLLATION(?)
FOUND_ROWS:FOUND_ROWS ()
DATABASE:DATABASE()
USER:USER()