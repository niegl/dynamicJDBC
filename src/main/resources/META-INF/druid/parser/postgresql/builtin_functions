[Logical Operators]
AND	    :A AND B	:TRUE if both A and B are TRUE, otherwise FALSE. NULL if A or B is NULL.
OR 	    :A OR B		:TRUE if either A or B or both are TRUE, FALSE OR NULL is NULL, otherwise FALSE.
NOT A	:NOT ?		:TRUE if A is FALSE or NULL if A is NULL. Otherwise FALSE.
[Comparison Functions and Operators]
[-->Comparison Operators]
datatype < datatype → boolean	:datatype < datatype    :Less than
datatype > datatype → boolean	:datatype > datatype    :Greater than
datatype <= datatype → boolean	:datatype <= datatype   :Less than or equal to
datatype >= datatype → boolean	:datatype >= datatype   :Greater than or equal to
datatype = datatype → boolean	:datatype = datatype    :Equal
datatype <> datatype → boolean	:datatype <> datatype   :Not equal
datatype != datatype → boolean	:datatype != datatype   :Not equal
[-->Comparison Predicates]
datatype BETWEEN datatype AND datatype → boolean        :datatype BETWEEN datatype AND datatype :Between (inclusive of the range endpoints).
datatype NOT BETWEEN datatype AND datatype → boolean    :datatype NOT BETWEEN datatype AND datatype :Not between (the negation of BETWEEN).
datatype BETWEEN SYMMETRIC datatype AND datatype → boolean  :datatype BETWEEN SYMMETRIC datatype AND datatype    :Between, after sorting the two endpoint values.
datatype NOT BETWEEN SYMMETRIC datatype AND datatype → boolean  :datatype NOT BETWEEN SYMMETRIC datatype AND datatype   :Not between, after sorting the two endpoint values.
datatype IS DISTINCT FROM datatype → boolean    :datatype IS DISTINCT FROM datatype   :Not equal, treating null as a comparable value.
datatype IS NOT DISTINCT FROM datatype → boolean    :datatype IS NOT DISTINCT FROM datatype   :Equal, treating null as a comparable value.
datatype IS NULL → boolean  :? IS NULL   :Test whether value is null.
datatype IS NOT NULL → boolean  :? IS NOT NULL   :Test whether value is not null.
datatype ISNULL → boolean   :? ISNULL    :Test whether value is null (nonstandard syntax).
datatype NOTNULL → boolean  :? NOTNULL   :Test whether value is not null (nonstandard syntax).
boolean IS TRUE → boolean   :? IS TRUE  :Test whether boolean expression yields true.
boolean IS NOT TRUE → boolean   :? IS NOT TRUE  :Test whether boolean expression yields false or unknown.
boolean IS FALSE → boolean  :? IS FALSE   :Test whether boolean expression yields false.
boolean IS NOT FALSE → boolean  :? IS NOT FALSE   :Test whether boolean expression yields true or unknown.
boolean IS UNKNOWN → boolean    :? IS UNKNOWN     :Test whether boolean expression yields unknown.
boolean IS NOT UNKNOWN → boolean    :? IS NOT UNKNOWN :Test whether boolean expression yields true or false.
[-->Comparison Functions]
num_nonnulls ( VARIADIC "any" ) → integer   :num_nonnulls ( VARIADIC "any" )    :Returns the number of non-null arguments.
num_nulls ( VARIADIC "any" ) → integer      :num_nulls ( VARIADIC "any" )       :Returns the number of null arguments.
[Mathematical Functions and Operators]
[-->Mathematical Operators]
numeric_type + numeric_type → numeric_type  :numeric_type + numeric_type   :Addition
+ numeric_type → numeric_type   :+ ? :Unary plus (no operation)
numeric_type - numeric_type → numeric_type  :numeric_type - numeric_type   :Subtraction
- numeric_type → numeric_type   :- ?   :Negation
numeric_type * numeric_type → numeric_type  :numeric_type * numeric_type   :Multiplication
numeric_type / numeric_type → numeric_type  :numeric_type / numeric_type   :Division (for integral types, division truncates the result towards zero)
numeric_type % numeric_type → numeric_type  :numeric_type % numeric_type    :Modulo (remainder); available for smallint, integer, bigint, and numeric
numeric ^ numeric → numeric     :numeric ^ numeric       :double precision ^ double precision → double precision
|/ double precision → double precision      :|/ ?    :Square root
||/ double precision → double precision     :||/ ?       :
@ numeric_type → numeric_type   : @ ?  :Absolute value
integral_type & integral_type → integral_type   :integral_type & integral_type   :Bitwise AND
integral_type | integral_type → integral_type   :integral_type | integral_type      :Bitwise OR
integral_type # integral_type → integral_type   :integral_type # integral_type      :Bitwise exclusive OR
~ integral_type → integral_type     :~ ?   :Bitwise NOT
integral_type << integer → integral_type    :integral_type << integer   :Bitwise shift left
integral_type >> integer → integral_type    :integral_type >> integer   :Bitwise shift right
[-->Mathematical Functions]
abs ( numeric_type ) → numeric_type					    :abs ( ? )	                                    :Absolute value
cbrt ( double precision ) → double precision		    :cbrt ( ? )	                                    :Cube root
ceil ( numeric ) → numeric							    :ceil ( ? )			                            :Nearest integer greater than or equal to argument
ceil ( double precision ) → double precision		    :ceil ( ? )	                                    :Nearest integer greater than or equal to argument
ceiling ( numeric ) → numeric						    :ceiling ( numeric )	                        :Nearest integer greater than or equal to argument (same as ceil)
ceiling ( double precision ) → double precision		    :ceiling ( ? )	                                :Nearest integer greater than or equal to argument (same as ceil)
degrees ( double precision ) → double precision		    :degrees ( ? )	                                :Converts radians to degrees
div ( y numeric, x numeric ) → numeric				    :div ( y numeric, x numeric )	                :Integer quotient of y/x (truncates towards zero)
exp ( numeric ) → numeric							    :exp ( ? )	                                    :Exponential (e raised to the given power)
exp ( double precision ) → double precision			    :exp ( ? )	                                    :Exponential (e raised to the given power)
factorial ( bigint ) → numeric						    :factorial ( ? )	                            :Factorial
floor ( numeric ) → numeric							    :floor ( ? )	                                :Nearest integer less than or equal to argument
floor ( double precision ) → double precision		    :floor ( ? )	                                :Nearest integer less than or equal to argument
gcd ( numeric_type, numeric_type ) → numeric_type	    :gcd ( numeric_type, numeric_type )	            :Greatest common divisor (the largest positive number that divides both inputs with no remainder); returns 0 if both inputs are zero; available for integer, bigint, and numeric
lcm ( numeric_type, numeric_type ) → numeric_type	    :lcm ( numeric_type, numeric_type )	            :Least common multiple (the smallest strictly positive number that is an integral multiple of both inputs); returns 0 if either input is zero; available for integer, bigint, and numeric
ln ( numeric ) → numeric							    :ln ( ? )	                                    :Natural logarithm
ln ( double precision ) → double precision			    :ln ( ? )	                                    :Natural logarithm
log ( numeric ) → numeric							    :log ( ? )	                                    :Base 10 logarithm
log ( double precision ) → double precision			    :log ( ? )	                                    :Base 10 logarithm
log10 ( numeric ) → numeric							    :log10 ( ? )	                                :Base 10 logarithm (same as log)
log10 ( double precision ) → double precision		    :log10 ( ? )	                                :Base 10 logarithm (same as log)
log ( b numeric, x numeric ) → numeric				    :log ( b numeric, x numeric )	                :Logarithm of x to base b
min_scale ( numeric ) → integer						    :min_scale ( ? )	                            :Minimum scale (number of fractional decimal digits) needed to represent the supplied value precisely
mod ( y numeric_type, x numeric_type ) → numeric_type	:mod ( y numeric_type, x numeric_type )	        :Remainder of y/x; available for smallint, integer, bigint, and numeric
pi ( ) → double precision							    :pi ( )	                                        :Approximate value of π
power ( a numeric, b numeric ) → numeric		        :power ( a numeric, b numeric )	                :a raised to the power of b
power ( a double precision, b double precision ) → double precision		            :power ( a double precision, b double precision )	    :a raised to the power of b
radians ( double precision ) → double precision		    :radians ( ? )	                                :Converts degrees to radians
round ( numeric ) → numeric							    :round ( ? )	                                :Rounds to nearest integer. For numeric, ties are broken by rounding away from zero. For double precision, the tie-breaking behavior is platform dependent, but “round to nearest even” is the most common rule.
round ( double precision ) → double precision		    :round ( ? )	                                :Rounds to nearest integer. For numeric, ties are broken by rounding away from zero. For double precision, the tie-breaking behavior is platform dependent, but “round to nearest even” is the most common rule.
round ( v numeric, s integer ) → numeric			    :round ( v numeric, s integer )	                :Rounds v to s decimal places. Ties are broken by rounding away from zero.
scale ( numeric ) → integer							    :scale ( ? )	                                :Scale of the argument (the number of decimal digits in the fractional part)
sign ( numeric ) → numeric							    :sign ( ? )	                                    :Sign of the argument (-1, 0, or +1)
sign ( double precision ) → double precision		    :sign ( ? )	                                    :Sign of the argument (-1, 0, or +1)
sqrt ( numeric ) → numeric							    :sqrt ( ? )	                                    :Square root
sqrt ( double precision ) → double precision		    :sqrt ( ? )	                                    :Square root
trim_scale ( numeric ) → numeric					    :trim_scale( ? )	                            :Reduces the value's scale (number of fractional decimal digits) by removing trailing zeroes
trunc ( numeric ) → numeric							    :trunc( ? )	                                    :Truncates to integer (towards zero)
trunc ( double precision ) → double precision		    :trunc( ? )	                                    :Truncates to integer (towards zero)
trunc ( v numeric, s integer ) → numeric			    :trunc ( v numeric, s integer )	                :Truncates v to s decimal places
width_bucket ( operand numeric, low numeric, high numeric, count integer ) → integer							:width_bucket ( operand numeric, low numeric, high numeric, count integer )	:Returns the number of the bucket in which operand falls in a histogram having count equal-width buckets spanning the range low to high. Returns 0 or count+1 for an input outside that range.
width_bucket ( operand double precision, low double precision, high double precision, count integer ) → integer	:width_bucket ( operand double precision, low double precision, high double precision, count integer )	:Returns the number of the bucket in which operand falls in a histogram having count equal-width buckets spanning the range low to high. Returns 0 or count+1 for an input outside that range.
width_bucket ( operand anycompatible, thresholds anycompatiblearray ) → integer									:width_bucket ( operand anycompatible, thresholds anycompatiblearray )	:Returns the number of the bucket in which operand falls given an array listing the lower bounds of the buckets. Returns 0 for an input less than the first lower bound. operand and the array elements can be of any type having standard comparison operators. The thresholds array must be sorted, smallest first, or unexpected results will be obtained.
[-->Random Functions]
random ( ) → double precision			:random ( )	:Returns a random value in the range 0.0 <= x < 1.0
setseed ( double precision ) → void		:setseed ( ? )	:Sets the seed for subsequent random() calls; argument must be between -1.0 and 1.0, inclusive
[-->Trigonometric Functions]
acos ( double precision ) → double precision							:acos ( ? )		:Inverse cosine, result in radians
acosd ( double precision ) → double precision							:acosd( ? )		:Inverse cosine, result in degrees
asin ( double precision ) → double precision							:asin( ? )		:Inverse sine, result in radians
asind ( double precision ) → double precision							:asind( ? )		:Inverse sine, result in degrees
atan ( double precision ) → double precision							:atan ( ? )		:Inverse tangent, result in radians
atand ( double precision ) → double precision							:atand( ? )		:Inverse tangent, result in degrees
atan2 ( y double precision, x double precision ) → double precision		:atan2( ? )		:Inverse tangent of y/x, result in radians
atan2d ( y double precision, x double precision ) → double precision	:atan2d( ? )	:Inverse tangent of y/x, result in degrees
cos ( double precision ) → double precision								:cos ( ? )		:Cosine, argument in radians
cosd ( double precision ) → double precision							:cosd( ? )		:Cosine, argument in degrees
cot ( double precision ) → double precision								:cot ( ? )		:Cotangent, argument in radians
cotd ( double precision ) → double precision							:cotd( ? )		:Cotangent, argument in degrees
sin ( double precision ) → double precision								:sin ( ? )		:Sine, argument in radians
sind ( double precision ) → double precision							:sind( ? )		:Sine, argument in degrees
tan ( double precision ) → double precision								:tan ( ? )		:Tangent, argument in radians
tand ( double precision ) → double precision							:tand( ? )		:Tangent, argument in degrees
[-->Hyperbolic Functions]
sinh ( double precision ) → double precision		:sinh ( ? )  	:Hyperbolic sine
cosh ( double precision ) → double precision		:cosh ( ? ) 	:Hyperbolic cosine
tanh ( double precision ) → double precision		:tanh ( ? ) 	:Hyperbolic tangent
asinh ( double precision ) → double precision		:asinh ( ? )	:Inverse hyperbolic sine
acosh ( double precision ) → double precision		:acosh ( ? )	:Inverse hyperbolic cosine
atanh ( double precision ) → double precision		:atanh ( ? )	:Inverse hyperbolic tangent
[String Functions and Operators]
[-->SQL String Functions and Operators]
text || text → text																					:text || text	                                                                                :Concatenates the two strings.
text || anynonarray → text																			:text || anynonarray	                                                                        :Converts the non-string input to text, then concatenates the two strings. (The non-string input cannot be of an array type, because that would create ambiguity with the array || operators. If you want to concatenate an array's text equivalent, cast it to text explicitly.)
anynonarray || text → text																			:anynonarray || text	                                                                        :Converts the non-string input to text, then concatenates the two strings. (The non-string input cannot be of an array type, because that would create ambiguity with the array || operators. If you want to concatenate an array's text equivalent, cast it to text explicitly.)
text IS [NOT] [form] NORMALIZED → boolean															:? IS [NOT] [NFC|NFD|NFKC|NFKD] NORMALIZED	                                                    :Checks whether the string is in the specified Unicode normalization form. The optional form key word specifies the form: NFC (the default), NFD, NFKC, or NFKD. This expression can only be used when the server encoding is UTF8. Note that checking for normalization using this expression is often faster than normalizing possibly already normalized strings.
bit_length ( text ) → integer																		:bit_length ( ? )	                                                                            :Returns number of bits in the string (8 times the octet_length).
char_length ( text ) → integer																		:char_length ( ? )	                                                                            :Returns number of characters in the string.
character_length ( text ) → integer																	:character_length ( ? )	                                                                        :Returns number of characters in the string.
lower ( text ) → text																				:lower ( ? )	                                                                                :Converts the string to all lower case, according to the rules of the database's locale.
normalize ( text [, form ] ) → text																	:normalize ( ? [, NFC|NFD|NFKC|NFKD ] )	                                                        :Converts the string to the specified Unicode normalization form. The optional form key word specifies the form: NFC (the default), NFD, NFKC, or NFKD. This function can only be used when the server encoding is UTF8.
octet_length ( text ) → integer																		:octet_length ( ? )	                                                                            :Returns number of bytes in the string.
octet_length ( character ) → integer																:octet_length ( ? )	                                                                            :Returns number of bytes in the string. Since this version of the function accepts type character directly, it will not strip trailing spaces.
overlay ( string text PLACING newsubstring text FROM start integer [ FOR count integer ] ) → text	:overlay ( string text PLACING newsubstring text FROM start integer [ FOR count integer ] )	    :Replaces the substring of string that starts at the start'th character and extends for count characters with newsubstring. If count is omitted, it defaults to the length of newsubstring.
position ( substring text IN string text ) → integer												:position ( substring text IN string text )	                                                    :Returns first starting index of the specified substring within string, or zero if it's not present.
substring ( string text [ FROM start integer ] [ FOR count integer ] ) → text						:substring ( string text [ FROM start integer ] [ FOR count integer ] )	                        :Extracts the substring of string starting at the start'th character if that is specified, and stopping after count characters if that is specified. Provide at least one of start and count.
substring ( string text FROM pattern text ) → text													:substring ( string text FROM pattern text )	                                                :Extracts the first substring matching POSIX regular expression; see Section 9.7.3.
substring ( string text SIMILAR pattern text ESCAPE escape text ) → text							:substring ( string text SIMILAR pattern text ESCAPE escape text )	                            :Extracts the first substring matching SQL regular expression; see Section 9.7.2. The first form has been specified since SQL:2003; the second form was only in SQL:1999 and should be considered obsolete.
substring ( string text FROM pattern text FOR escape text ) → text									:substring ( string text FROM pattern text FOR escape text )	                                :Extracts the first substring matching SQL regular expression; see Section 9.7.2. The first form has been specified since SQL:2003; the second form was only in SQL:1999 and should be considered obsolete.
trim ( [ LEADING | TRAILING | BOTH ] [ characters text ] FROM string text ) → text					:trim ( [ LEADING | TRAILING | BOTH ] [ characters text ] FROM string text )	                :Removes the longest string containing only characters in characters (a space by default) from the start, end, or both ends (BOTH is the default) of string.
trim ( [ LEADING | TRAILING | BOTH ] [ FROM ] string text [, characters text ] ) → text				:trim ( [ LEADING | TRAILING | BOTH ] [ FROM ] string text [, characters text ] )	            :This is a non-standard syntax for trim().
upper ( text ) → text																				:upper ( ? )	                                                                                :Converts the string to all upper case, according to the rules of the database's locale.
[-->Other String Functions and Operators]
text ^@ text → boolean	                                            :text ^@ text 	                                            :Returns true if the first string starts with the second string (equivalent to the starts_with() function).
ascii ( text ) → integer                                            :ascii ( ? )                                            :Returns the numeric code of the first character of the argument. In UTF8 encoding, returns the Unicode code point of the character. In other multibyte encodings, the argument must be an ASCII character.
btrim ( string text [, characters text ] ) → text                   :btrim ( string text [, characters text ] )                   :Removes the longest string containing only characters in characters (a space by default) from the start and end of string.
chr ( integer ) → text                                              :chr ( ? )                                               :Returns the character with the given code. In UTF8 encoding the argument is treated as a Unicode code point. In other multibyte encodings the argument must designate an ASCII character. chr(0) is disallowed because text data types cannot store that character.
concat ( val1 "any" [, val2 "any" [, ...] ] ) → text                :concat ( val1 "any" [, val2 "any" [, ...] ] )                :Concatenates the text representations of all the arguments. NULL arguments are ignored.
concat_ws ( sep text, val1 "any" [, val2 "any" [, ...] ] ) → text   :concat_ws ( sep text, val1 "any" [, val2 "any" [, ...] ] )   :Concatenates all but the first argument, with separators. The first argument is used as the separator string, and should not be NULL. Other NULL arguments are ignored.
format ( formatstr text [, formatarg "any" [, ...] ] ) → text       :format ( formatstr text [, formatarg "any" [, ...] ] )       :Formats arguments according to a format string; see Section 9.4.1. This function is similar to the C function sprintf.
initcap ( text ) → text                                             :initcap ( ? )                                             :Converts the first letter of each word to upper case and the rest to lower case. Words are sequences of alphanumeric characters separated by non-alphanumeric characters.
left ( string text, n integer ) → text                              :left ( string text, n integer )                              :Returns first n characters in the string, or when n is negative, returns all but last |n| characters.
length ( text ) → integer                                           :length ( ? ) → integer                                           :Returns the number of characters in the string.
lpad ( string text, length integer [, fill text ] ) → text          :lpad ( string text, length integer [, fill text ] )           :Extends the string to length length by prepending the characters fill (a space by default). If the string is already longer than length then it is truncated (on the right).
ltrim ( string text [, characters text ] ) → text                   :ltrim ( string text [, characters text ] )                    :Removes the longest string containing only characters in characters (a space by default) from the start of string.
md5 ( text ) → text                                                 :md5 ( ? )                                                  :Computes the MD5 hash of the argument, with the result written in hexadecimal.
parse_ident ( qualified_identifier text [, strict_mode boolean DEFAULT true ] ) → text[]           :parse_ident ( qualified_identifier text [, strict_mode boolean DEFAULT true ] ):Splits qualified_identifier into an array of identifiers, removing any quoting of individual identifiers. By default, extra characters after the last identifier are considered an error; but if the second parameter is false, then such extra characters are ignored. (This behavior is useful for parsing names for objects like functions.) Note that this function does not truncate over-length identifiers. If you want truncation you can cast the result to name[].
pg_client_encoding ( ) → name                                       :pg_client_encoding ( )             :Returns current client encoding name.
quote_ident ( text ) → text                                         :quote_ident ( ? )               :Returns the given string suitably quoted to be used as an identifier in an SQL statement string. Quotes are added only if necessary (i.e., if the string contains non-identifier characters or would be case-folded). Embedded quotes are properly doubled. See also Example 43.1.
quote_literal ( text ) → text                                       :quote_literal ( ? )             :Returns the given string suitably quoted to be used as a string literal in an SQL statement string. Embedded single-quotes and backslashes are properly doubled. Note that quote_literal returns null on null input; if the argument might be null, quote_nullable is often more suitable. See also Example 43.1.
quote_literal ( anyelement ) → text                                 :quote_literal ( ? )       :Converts the given value to text and then quotes it as a literal. Embedded single-quotes and backslashes are properly doubled.
quote_nullable ( text ) → text                                      :quote_nullable ( ? )            :Returns the given string suitably quoted to be used as a string literal in an SQL statement string; or, if the argument is null, returns NULL. Embedded single-quotes and backslashes are properly doubled. See also Example 43.1.
quote_nullable ( anyelement ) → text                                :quote_nullable ( ? )      :Converts the given value to text and then quotes it as a literal; or, if the argument is null, returns NULL. Embedded single-quotes and backslashes are properly doubled.
regexp_count ( string text, pattern text [, start integer [, flags text ] ] ) → integer     :regexp_count ( string text, pattern text [, start integer [, flags text ] ] ):Returns the number of times the POSIX regular expression pattern matches in the string; see Section 9.7.3.
regexp_instr ( string text, pattern text [, start integer [, N integer [, endoption integer [, flags text [, subexpr integer ] ] ] ] ] ) → integer  :regexp_instr ( string text, pattern text [, start integer [, N integer [, endoption integer [, flags text [, subexpr integer ] ] ] ] ] ):Returns the position within string where the N'th match of the POSIX regular expression pattern occurs, or zero if there is no such match; see Section 9.7.3.
regexp_like ( string text, pattern text [, flags text ] ) → boolean :regexp_like ( string text, pattern text [, flags text ] ):Checks whether a match of the POSIX regular expression pattern occurs within string; see Section 9.7.3.
regexp_match ( string text, pattern text [, flags text ] ) → text[] :regexp_match ( string text, pattern text [, flags text ] ):Returns substrings within the first match of the POSIX regular expression pattern to the string; see Section 9.7.3.
regexp_matches ( string text, pattern text [, flags text ] ) → setof text[] :regexp_matches ( string text, pattern text [, flags text ] ):Returns substrings within the first match of the POSIX regular expression pattern to the string, or substrings within all such matches if the g flag is used; see Section 9.7.3.
regexp_replace ( string text, pattern text, replacement text [, start integer ] [, flags text ] ) → text        :regexp_replace ( string text, pattern text, replacement text [, start integer ] [, flags text ] ):Replaces the substring that is the first match to the POSIX regular expression pattern, or all such matches if the g flag is used; see Section 9.7.3.
regexp_replace ( string text, pattern text, replacement text, start integer, N integer [, flags text ] ) → text :regexp_replace ( string text, pattern text, replacement text, start integer, N integer [, flags text ] ):Replaces the substring that is the N'th match to the POSIX regular expression pattern, or all such matches if N is zero; see Section 9.7.3.
regexp_split_to_array ( string text, pattern text [, flags text ] ) → text[]        :regexp_split_to_array ( string text, pattern text [, flags text ] ):Splits string using a POSIX regular expression as the delimiter, producing an array of results; see Section 9.7.3.
regexp_split_to_table ( string text, pattern text [, flags text ] ) → setof text    :regexp_split_to_table ( string text, pattern text [, flags text ] ):Splits string using a POSIX regular expression as the delimiter, producing a set of results; see Section 9.7.3.
regexp_substr ( string text, pattern text [, start integer [, N integer [, flags text [, subexpr integer ] ] ] ] ) → text   :regexp_substr ( string text, pattern text [, start integer [, N integer [, flags text [, subexpr integer ] ] ] ] ):Returns the substring within string that matches the N'th occurrence of the POSIX regular expression pattern, or NULL if there is no such match; see Section 9.7.3.
repeat ( string text, number integer ) → text                       :repeat ( string text, number integer )                 :Repeats string the specified number of times.
replace ( string text, from text, to text ) → text                  :replace ( string text, from text, to text )            :Replaces all occurrences in string of substring from with substring to.
reverse ( text ) → text                                             :reverse ( ? )                                       :Reverses the order of the characters in the string.
right ( string text, n integer ) → text                             :right ( string text, n integer )                       :Returns last n characters in the string, or when n is negative, returns all but first |n| characters.
rpad ( string text, length integer [, fill text ] ) → text          :rpad ( string text, length integer [, fill text ] )    :Extends the string to length length by appending the characters fill (a space by default). If the string is already longer than length then it is truncated.
rtrim ( string text [, characters text ] ) → text                   :rtrim ( string text [, characters text ] )             :Removes the longest string containing only characters in characters (a space by default) from the end of string.
split_part ( string text, delimiter text, n integer ) → text        :split_part ( string text, delimiter text, n integer )  :Splits string at occurrences of delimiter and returns the n'th field (counting from one), or when n is negative, returns the |n|'th-from-last field.
starts_with ( string text, prefix text ) → boolean                  :starts_with ( string text, prefix text )               :Returns true if string starts with prefix.
string_to_array ( string text, delimiter text [, null_string text ] ) → text[]      :string_to_array ( string text, delimiter text [, null_string text ] ):Splits the string at occurrences of delimiter and forms the resulting fields into a text array. If delimiter is NULL, each character in the string will become a separate element in the array. If delimiter is an empty string, then the string is treated as a single field. If null_string is supplied and is not NULL, fields matching that string are replaced by NULL. See also array_to_string.
string_to_table ( string text, delimiter text [, null_string text ] ) → setof text  :string_to_table ( string text, delimiter text [, null_string text ] ):Splits the string at occurrences of delimiter and returns the resulting fields as a set of text rows. If delimiter is NULL, each character in the string will become a separate row of the result. If delimiter is an empty string, then the string is treated as a single field. If null_string is supplied and is not NULL, fields matching that string are replaced by NULL.
strpos ( string text, substring text ) → integer                    :strpos ( string text, substring text )         :Returns first starting index of the specified substring within string, or zero if it's not present. (Same as position(substring in string), but note the reversed argument order.)
substr ( string text, start integer [, count integer ] ) → text     :substr ( string text, start integer [, count integer ] ):Extracts the substring of string starting at the start'th character, and extending for count characters if that is specified. (Same as substring(string from start for count).)
to_ascii ( string text ) → text                                     :to_ascii ( ? )                          :Converts string to ASCII from another encoding, which may be identified by name or number. If encoding is omitted the database encoding is assumed (which in practice is the only useful case). The conversion consists primarily of dropping accents. Conversion is only supported from LATIN1, LATIN2, LATIN9, and WIN1250 encodings. (See the unaccent module for another, more flexible solution.)
to_ascii ( string text, encoding name ) → text                      :to_ascii ( string text, 'LATIN1|'LATIN2'|'LATIN9'|'WIN1250' )           :Converts string to ASCII from another encoding, which may be identified by name or number. If encoding is omitted the database encoding is assumed (which in practice is the only useful case). The conversion consists primarily of dropping accents. Conversion is only supported from LATIN1, LATIN2, LATIN9, and WIN1250 encodings. (See the unaccent module for another, more flexible solution.)
to_hex ( integer ) → text                                           :to_hex ( ? )                                :Converts the number to its equivalent hexadecimal representation.
to_hex ( bigint ) → text                                            :to_hex ( ? )                                 :Converts the number to its equivalent hexadecimal representation.
translate ( string text, from text, to text ) → text                :translate ( string text, from text, to text )     :Replaces each character in string that matches a character in the from set with the corresponding character in the to set. If from is longer than to, occurrences of the extra characters in from are deleted.
unistr ( text ) → text                                              :unistr ( ? )                                   :Evaluate escaped Unicode characters in the argument. Unicode characters can be specified as \XXXX (4 hexadecimal digits), \+XXXXXX (6 hexadecimal digits), \uXXXX (4 hexadecimal digits), or \UXXXXXXXX (8 hexadecimal digits). To specify a backslash, write two backslashes. All other characters are taken literally.
[-->format]
format(formatstr text [, formatarg "any" [, ...] ])     :format(formatstr text [, formatarg "any" [, ...] ])    :The function format produces output formatted according to a format string, in a style similar to the C function sprintf.
[Binary String Functions and Operators]
[-->SQL Binary String Functions and Operators]
bytea || bytea → bytea				:bytea || bytea 				:Concatenates the two binary strings.
bit_length ( bytea ) → integer		:bit_length ( ? ) 		    :Returns number of bits in the binary string (8 times the octet_length).
octet_length ( bytea ) → integer	:octet_length ( ? ) 	    :Returns number of bytes in the binary string.
overlay ( bytes bytea PLACING newsubstring bytea FROM start integer [ FOR count integer ] ) → bytea		:overlay ( bytes bytea PLACING newsubstring bytea FROM start integer [ FOR count integer ] )    :Replaces the substring of bytes that starts at the start'th byte and extends for count bytes with newsubstring. If count is omitted, it defaults to the length of newsubstring.
position ( substring bytea IN bytes bytea ) → integer									                :position ( substring bytea IN bytes bytea ) 								                :Returns first starting index of the specified substring within bytes, or zero if it's not present.
substring ( bytes bytea [ FROM start integer ] [ FOR count integer ] ) → bytea			                :substring ( bytes bytea [ FROM start integer ] [ FOR count integer ] ) 		            :Extracts the substring of bytes starting at the start'th byte if that is specified, and stopping after count bytes if that is specified. Provide at least one of start and count.
trim ( [ LEADING | TRAILING | BOTH ] bytesremoved bytea FROM bytes bytea ) → bytea		                :trim ( [ LEADING | TRAILING | BOTH ] bytesremoved bytea FROM bytes bytea ) 	            :Removes the longest string containing only bytes appearing in bytesremoved from the start, end, or both ends (BOTH is the default) of bytes.
trim ( [ LEADING | TRAILING | BOTH ] [ FROM ] bytes bytea, bytesremoved bytea ) → bytea	                :trim ( [ LEADING | TRAILING | BOTH ] [ FROM ] bytes bytea, bytesremoved bytea )            :This is a non-standard syntax for trim().
[-->Other Binary String Functions]
bit_count ( bytes bytea ) → bigint								:bit_count ( bytes bytea ) 									:Returns the number of bits set in the binary string (also known as “popcount”).
btrim ( bytes bytea, bytesremoved bytea ) → bytea				:btrim ( bytes bytea, bytesremoved bytea ) 					:Removes the longest string containing only bytes appearing in bytesremoved from the start and end of bytes.
get_bit ( bytes bytea, n bigint ) → integer						:get_bit ( bytes bytea, n bigint ) 							:Extracts n'th bit from binary string.
get_byte ( bytes bytea, n integer ) → integer					:get_byte ( bytes bytea, n integer ) 						:Extracts n'th byte from binary string.
length ( bytea ) → integer										:length ( ? ) 											:Returns the number of bytes in the binary string.
length ( bytes bytea, encoding name ) → integer					:length ( bytes bytea, encoding name ) 						:Returns the number of characters in the binary string, assuming that it is text in the given encoding.
ltrim ( bytes bytea, bytesremoved bytea ) → bytea				:ltrim ( bytes bytea, bytesremoved bytea ) 					:Removes the longest string containing only bytes appearing in bytesremoved from the start of bytes.
md5 ( bytea ) → text											:md5 ( ? ) 												:Computes the MD5 hash of the binary string, with the result written in hexadecimal.
rtrim ( bytes bytea, bytesremoved bytea ) → bytea				:rtrim ( bytes bytea, bytesremoved bytea ) 					:Removes the longest string containing only bytes appearing in bytesremoved from the end of bytes.
set_bit ( bytes bytea, n bigint, newvalue integer ) → bytea		:set_bit ( bytes bytea, n bigint, newvalue integer ) 		:Sets n'th bit in binary string to newvalue.
set_byte ( bytes bytea, n integer, newvalue integer ) → bytea	:set_byte ( bytes bytea, n integer, newvalue integer ) 		:Sets n'th byte in binary string to newvalue.
sha224 ( bytea ) → bytea										:sha224 ( ? ) 											:Computes the SHA-224 hash of the binary string.
sha256 ( bytea ) → bytea										:sha256 ( ? ) 											:Computes the SHA-256 hash of the binary string.
sha384 ( bytea ) → bytea										:sha384 ( ? ) 											:Computes the SHA-384 hash of the binary string.
sha512 ( bytea ) → bytea										:sha512 ( ? ) 											:Computes the SHA-512 hash of the binary string.
substr ( bytes bytea, start integer [, count integer ] ) → bytea:substr ( bytes bytea, start integer [, count integer ] ) 	:Extracts the substring of bytes starting at the start'th byte, and extending for count bytes if that is specified. (Same as substring(bytes from start for count).)
[-->Text/Binary String Conversion Functions]
convert ( bytes bytea, src_encoding name, dest_encoding name ) → bytea		:convert ( bytes bytea, UTF8|LATIN1|GBK|SQL_ASCII..., UTF8|LATIN1|GBK|SQL_ASCII... ) :Converts a binary string representing text in encoding src_encoding to a binary string in encoding dest_encoding (see Section 24.3.4 for available conversions).
convert_from ( bytes bytea,  src_encoding name) → text						:convert_from ( bytes bytea, UTF8|LATIN1|GBK|SQL_ASCII... ) 				:Converts a binary string representing text in encoding src_encoding to text in the database encoding (see Section 24.3.4 for available conversions).
convert_to ( string text, dest_encoding name ) → bytea						:convert_to ( string text, UTF8|LATIN1|GBK|SQL_ASCII... ) 				:Converts a text string (in the database encoding) to a binary string encoded in encoding dest_encoding (see Section 24.3.4 for available conversions).
encode ( bytes bytea, format text) → text									:encode ( bytes bytea, 'base64'|'escape'|'hex' )							:Encodes binary data into a textual representation; supported format values are: base64, escape, hex.
decode ( string text, format text) → bytea									:decode ( string text, 'base64'|'escape'|'hex' )							:Decodes binary data from a textual representation; supported format values are the same as for encode.
[Bit String Functions and Operators]
[-->Bit String Operators]
bit || bit → bit		:bit || bit 		:Concatenation
bit & bit → bit			:bit & bit 			:Bitwise AND (inputs must be of equal length)
bit | bit → bit			:bit | bit 			:Bitwise OR (inputs must be of equal length)
bit # bit → bit			:bit # bit 			:Bitwise exclusive OR (inputs must be of equal length)
~ bit → bit				:~ bit 				:Bitwise NOT
bit << integer → bit	:bit << integer 	:Bitwise shift left (string length is preserved)
bit >> integer → bit	:bit >> integer 	:Bitwise shift right (string length is preserved)
[-->Bit String Functions]
bit_count ( bit ) → bigint              :bit_count ( ? )              :Returns the number of bits set in the bit string (also known as “popcount”).
bit_length ( bit ) → integer            :bit_length ( ? )             :Returns number of bits in the bit string.
length ( bit ) → integer                :length ( ? )                 :Returns number of bits in the bit string.
octet_length ( bit ) → integer          :octet_length ( ? )           :Returns number of bytes in the bit string.
overlay ( bits bit PLACING newsubstring bit FROM start integer [ FOR count integer ] ) → bit                                                        :overlay ( bits bit PLACING newsubstring bit FROM start integer [ FOR count integer ] ):Replaces the substring of bits that starts at the start'th bit and extends for count bits with newsubstring. If count is omitted, it defaults to the length of newsubstring.
position ( substring bit IN bits bit ) → integer                            :position ( substring bit IN bits bit )                                 :Returns first starting index of the specified substring within bits, or zero if it's not present.
substring ( bits bit [ FROM start integer ] [ FOR count integer ] ) → bit   :substring ( bits bit [ FROM start integer ] [ FOR count integer ] )    :Extracts the substring of bits starting at the start'th bit if that is specified, and stopping after count bits if that is specified. Provide at least one of start and count.
get_bit ( bits bit, n integer ) → integer                   :get_bit ( bits bit, n integer )                                                        :Extracts n'th bit from bit string; the first (leftmost) bit is bit 0.
set_bit ( bits bit, n integer, newvalue integer ) → bit     :set_bit ( bits bit, n integer, newvalue integer )                                      :Sets n'th bit in bit string to newvalue; the first (leftmost) bit is bit 0.
[Pattern Matching]
[-->LIKE]
LIKE                :string LIKE pattern [ESCAPE escape-character]      :The LIKE expression returns true if the string matches the supplied pattern. (As expected, the NOT LIKE expression returns false if LIKE returns true, and vice versa. An equivalent expression is NOT (string LIKE pattern).)
NOT LIKE            :string NOT LIKE pattern [ESCAPE escape-character]  :The LIKE expression returns true if the string matches the supplied pattern. (As expected, the NOT LIKE expression returns false if LIKE returns true, and vice versa. An equivalent expression is NOT (string LIKE pattern).)
[-->SIMILAR TO Regular Expressions]
SIMILAR TO          :string SIMILAR TO pattern [ESCAPE escape-character]            :The SIMILAR TO operator returns true or false depending on whether its pattern matches the given string. It is similar to LIKE, except that it interprets the pattern using the SQL standard's definition of a regular expression. SQL regular expressions are a curious cross between LIKE notation and common (POSIX) regular expression notation.
NOT SIMILAR TO      :string NOT SIMILAR TO pattern [ESCAPE escape-character]        :The SIMILAR TO operator returns true or false depending on whether its pattern matches the given string. It is similar to LIKE, except that it interprets the pattern using the SQL standard's definition of a regular expression. SQL regular expressions are a curious cross between LIKE notation and common (POSIX) regular expression notation.
[-->POSIX Regular Expressions]
text ~ text 	    :text ~ text → boolean		：String matches regular expression, case sensitively
text ~* text 	    :text ~* text → boolean		：String matches regular expression, case insensitively
text !~ text 	    :text !~ text → boolean		：String does not match regular expression, case sensitively
text !~* text	    :text !~* text → boolean	：String does not match regular expression, case insensitively
[Data Type Formatting Functions]
to_char ( timestamp, text ) → text               		:to_char ( timestamp, text )           :Converts time stamp to string according to the given format.
to_char ( timestamp with time zone, text ) → text		:to_char ( timestamp with time zone, text ) :Converts time stamp to string according to the given format.
to_char ( interval, text ) → text						:to_char ( interval, text ) 			:Converts interval to string according to the given format.
to_char ( numeric_type, text ) → text					:to_char ( numeric_type, text ) 		:Converts number to string according to the given format; available for integer, bigint, numeric, real, double precision.
to_date ( text, text ) → date							:to_date ( text, text ) 				:Converts string to date according to the given format.
to_number ( text, text ) → numeric						:to_number ( text, text ) 				:Converts string to numeric according to the given format.
to_timestamp ( text, text ) → timestamp with time zone	:to_timestamp ( text, text )			:Converts string to time stamp according to the given format. (See also to_timestamp(double precision) in Table 9.33.)
[Date/Time Functions and Operators]
[-->Date/Time Operators]
date + integer → date					:date + integer 				:Add a number of days to a date
date + interval → timestamp				:date + interval 				:Add an interval to a date
date + time → timestamp					:date + time 					:Add a time-of-day to a date
interval + interval → interval			:interval + interval 			:Add intervals
timestamp + interval → timestamp		:timestamp + interval 			:Add an interval to a timestamp
time + interval → time					:time + interval 				:Add an interval to a time
- interval → interval					:- interval 					:Negate an interval
date - date → integer					:date - date 					:Subtract dates, producing the number of days elapsed
date - integer → date					:date - integer 				:Subtract a number of days from a date
date - interval → timestamp				:date - interval 				:Subtract an interval from a date
time - time → interval					:time - time 					:Subtract times
time - interval → time					:time - interval 				:Subtract an interval from a time
timestamp - interval → timestamp		:timestamp - interval 			:Subtract an interval from a timestamp
interval - interval → interval			:interval - interval 			:Subtract intervals
timestamp - timestamp → interval		:timestamp - timestamp 			:Subtract timestamps (converting 24-hour intervals into days, similarly to justify_hours())
interval * double precision → interval	:interval * double precision 	:Multiply an interval by a scalar
interval / double precision → interval	:interval / double precision  	:Divide an interval by a scalar
[-->Date/Time Functions]
age ( timestamp, timestamp ) → interval						:age ( timestamp, timestamp ) 						                        :Subtract arguments, producing a “symbolic” result that uses years and months, rather than just days
age ( timestamp ) → interval								:age ( timestamp ) 								 	                        :Subtract argument from current_date (at midnight)
clock_timestamp ( ) → timestamp with time zone				:clock_timestamp ( ) 				 				                        :Current date and time (changes during statement execution); see Section 9.9.5
current_date → date											:current_date 										                        :Current date; see Section 9.9.5
current_time → time with time zone							:current_time 							 			                        :Current time of day; see Section 9.9.5
current_time ( integer ) → time with time zone				:current_time ( integer ) 				 			                        :Current time of day, with limited precision; see Section 9.9.5
current_timestamp → timestamp with time zone				:current_timestamp 				 					                        :Current date and time (start of current transaction); see Section 9.9.5
current_timestamp ( integer ) → timestamp with time zone	:current_timestamp ( integer ) 	 					                        :Current date and time (start of current transaction), with limited precision; see Section 9.9.5
date_bin ( interval, timestamp, timestamp ) → timestamp		:date_bin ( interval, timestamp, timestamp ) 		                        :Bin input into specified interval aligned with specified origin; see Section 9.9.3
date_part ( text, timestamp ) → double precision			:date_part ( text, timestamp ) 			 			                        :Get timestamp subfield (equivalent to extract); see Section 9.9.1
date_part ( text, interval ) → double precision				:date_part ( text, interval ) 				 		                        :Get interval subfield (equivalent to extract); see Section 9.9.1
date_trunc ( text, timestamp ) → timestamp					:date_trunc ( text, timestamp ) 					                        :Truncate to specified precision; see Section 9.9.2
date_trunc ( text, timestamp with time zone, text ) → timestamp with time zone	:date_trunc ( text, timestamp with time zone, text )    :Truncate to specified precision in the specified time zone; see Section 9.9.2
date_trunc ( text, interval ) → interval					:date_trunc ( text, interval ) 					 	                        :Truncate to specified precision; see Section 9.9.2
extract ( field from timestamp ) → numeric					:extract ( field from timestamp ) 					                        :Get timestamp subfield; see Section 9.9.1
extract ( field from interval ) → numeric 					:extract ( field from interval )  					                        :Get interval subfield; see Section 9.9.1
isfinite ( date ) → boolean									:isfinite ( date ) 									                        :Test for finite date (not +/-infinity)
isfinite ( timestamp ) → boolean							:isfinite ( timestamp ) 							                        :Test for finite timestamp (not +/-infinity)
isfinite ( interval ) → boolean								:isfinite ( interval ) 								                        :Test for finite interval (currently always true)
justify_days ( interval ) → interval						:justify_days ( interval ) 						 	                        :Adjust interval so 30-day time periods are represented as months
justify_hours ( interval ) → interval						:justify_hours ( interval ) 						                        :Adjust interval so 24-hour time periods are represented as days
justify_interval ( interval ) → interval					:justify_interval ( interval ) 					 	                        :Adjust interval using justify_days and justify_hours, with additional sign adjustments
localtime → time											:localtime 										 	                        :Current time of day; see Section 9.9.5
localtime ( integer ) → time								:localtime ( integer ) 								                        :Current time of day, with limited precision; see Section 9.9.5
localtimestamp → timestamp									:localtimestamp 									                        :Current date and time (start of current transaction); see Section 9.9.5
localtimestamp ( integer ) → timestamp						:localtimestamp ( integer ) 						                        :Current date and time (start of current transaction), with limited precision; see Section 9.9.5
make_date ( year int, month int, day int ) → date			:make_date ( year int, month int, day int ) 		                        :Create date from year, month and day fields (negative years signify BC)
make_interval ( [ years int [, months int [, weeks int [, days int [, hours int [, mins int [, secs double precision ]]]]]]] ) → interval:make_interval ( [ years int [, months int [, weeks int [, days int [, hours int [, mins int [, secs double precision ]]]]]]] ) :Create interval from years, months, weeks, days, hours, minutes and seconds fields, each of which can default to zero
make_time ( hour int, min int, sec double precision ) → time:make_time ( hour int, min int, sec double precision )                      :Create time from hour, minute and seconds fields
make_timestamp ( year int, month int, day int, hour int, min int, sec double precision ) → timestamp			:make_timestamp ( year int, month int, day int, hour int, min int, sec double precision ) :Create timestamp from year, month, day, hour, minute and seconds fields (negative years signify BC)
make_timestamptz ( year int, month int, day int, hour int, min int, sec double precision [, timezone text ] ) → timestamp with time zone	:make_timestamptz ( year int, month int, day int, hour int, min int, sec double precision [, timezone text ] ) :Create timestamp with time zone from year, month, day, hour, minute and seconds fields (negative years signify BC). If timezone is not specified, the current time zone is used; the examples assume the session time zone is Europe/London
now ( ) → timestamp with time zone							    :now ( ) 							 	:Current date and time (start of current transaction); see Section 9.9.5
statement_timestamp ( ) → timestamp with time zone			    :statement_timestamp ( ) 			 	:Current date and time (start of current statement); see Section 9.9.5
timeofday ( ) → text										    :timeofday ( ) 							:Current date and time (like clock_timestamp, but as a text string); see Section 9.9.5
transaction_timestamp ( ) → timestamp with time zone		    :transaction_timestamp ( ) 		 		:Current date and time (start of current transaction); see Section 9.9.5
to_timestamp ( double precision ) → timestamp with time zone    :to_timestamp ( double precision )  	:Convert Unix epoch (seconds since 1970-01-01 00:00:00+00) to timestamp with time zone
[-->EXTRACT, date_part]
EXTRACT(field FROM source)  :EXTRACT(field FROM source) :The extract function retrieves subfields such as year or hour from date/time values. source must be a value expression of type timestamp, time, or interval. (Expressions of type date are cast to timestamp and can therefore be used as well.) field is an identifier or string that selects what field to extract from the source value. The extract function returns values of type numeric.
date_part('field', source)  :date_part('field', source) :The date_part function is modeled on the traditional Ingres equivalent to the SQL-standard function extract
[-->date_trunc]
date_trunc(field, source [, time_zone ])    :date_trunc('microseconds'|'milliseconds'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'|'decade'|'century'|'millennium', source [, time_zone ])   :source is a value expression of type timestamp, timestamp with time zone, or interval. (Values of type date and time are cast automatically to timestamp or interval, respectively.) field selects to which precision to truncate the input value. The return value is likewise of type timestamp, timestamp with time zone, or interval, and it has all fields that are less significant than the selected one set to zero (or one, for day and month).
date_bin(stride, source, origin)            :date_bin(stride, source, origin)   :The function date_bin “bins” the input timestamp into the specified interval (the stride) aligned with a specified origin.
[-->AT TIME ZONE]
timestamp without time zone AT TIME ZONE zone → timestamp with time zone	:timestamp without time zone AT TIME ZONE zone	:Converts given time stamp without time zone to time stamp with time zone, assuming the given value is in the named time zone.
timestamp with time zone AT TIME ZONE zone → timestamp without time zone	:timestamp with time zone AT TIME ZONE zone		:Converts given time stamp with time zone to time stamp without time zone, as the time would appear in that zone.
time with time zone AT TIME ZONE zone → time with time zone					:time with time zone AT TIME ZONE zone			:Converts given time with time zone to a new time zone. Since no date is supplied, this uses the currently active UTC offset for the named destination zone.
[-->Current Date/Time]
CURRENT_DATE                      :CURRENT_DATE                 :CURRENT_TIME and CURRENT_TIMESTAMP deliver values with time zone; LOCALTIME and LOCALTIMESTAMP deliver values without time zone.
CURRENT_TIME                      :CURRENT_TIME                 :CURRENT_TIME and CURRENT_TIMESTAMP deliver values with time zone; LOCALTIME and LOCALTIMESTAMP deliver values without time zone.
CURRENT_TIMESTAMP                 :CURRENT_TIMESTAMP            :CURRENT_TIME and CURRENT_TIMESTAMP deliver values with time zone; LOCALTIME and LOCALTIMESTAMP deliver values without time zone.
CURRENT_TIME(precision)           :CURRENT_TIME(precision)      :CURRENT_TIME and CURRENT_TIMESTAMP deliver values with time zone; LOCALTIME and LOCALTIMESTAMP deliver values without time zone.
CURRENT_TIMESTAMP(precision)      :CURRENT_TIMESTAMP(precision) :CURRENT_TIME and CURRENT_TIMESTAMP deliver values with time zone; LOCALTIME and LOCALTIMESTAMP deliver values without time zone.
LOCALTIME                         :LOCALTIME                    :CURRENT_TIME and CURRENT_TIMESTAMP deliver values with time zone; LOCALTIME and LOCALTIMESTAMP deliver values without time zone.
LOCALTIMESTAMP                    :LOCALTIMESTAMP               :CURRENT_TIME and CURRENT_TIMESTAMP deliver values with time zone; LOCALTIME and LOCALTIMESTAMP deliver values without time zone.
LOCALTIME(precision)              :LOCALTIME(precision)         :CURRENT_TIME and CURRENT_TIMESTAMP deliver values with time zone; LOCALTIME and LOCALTIMESTAMP deliver values without time zone.
LOCALTIMESTAMP(precision)         :LOCALTIMESTAMP(precision)    :CURRENT_TIME and CURRENT_TIMESTAMP deliver values with time zone; LOCALTIME and LOCALTIMESTAMP deliver values without time zone.
[-->Delaying Execution]
pg_sleep ( double precision )                      :pg_sleep ( double precision )                  :pg_sleep makes the current session's process sleep until the given number of seconds have elapsed.
pg_sleep_for ( interval )                          :pg_sleep_for ( interval )                      :pg_sleep makes the current session's process sleep until the given number of seconds have elapsed.
pg_sleep_until ( timestamp with time zone )        :pg_sleep_until ( timestamp with time zone )    :pg_sleep_until is a convenience function for when a specific wake-up time is desired.
[Enum Support Functions]
enum_first ( anyenum ) → anyenum									    :enum_first ( anyenum ) 					:Returns the first value of the input enum type.
enum_last ( anyenum ) → anyenum										    :enum_last ( anyenum ) 						:Returns the last value of the input enum type.
enum_range ( anyenum ) → anyarray									    :enum_range ( anyenum ) 					:Returns all values of the input enum type in an ordered array.
enum_range ( anyenum, anyenum ) → anyarray                       	    :enum_range ( anyenum, anyenum )            :Returns the range between the two given enum values, as an ordered array. The values must be from the same enum type. If the first parameter is null, the result will start with the first value of the enum type. If the second parameter is null, the result will end with the last value of the enum type.
[Geometric Functions and Operators]
[-->Geometric Operators]
geometric_type + point → geometric_type				:geometric_type + point					:Adds the coordinates of the second point to those of each point of the first argument, thus performing translation. Available for point, box, path, circle.
path + path → path									:path + path							:Concatenates two open paths (returns NULL if either path is closed).
geometric_type - point → geometric_type				:geometric_type - point					:Subtracts the coordinates of the second point from those of each point of the first argument, thus performing translation. Available for point, box, path, circle.
geometric_type * point → geometric_type				:geometric_type * point					:Multiplies each point of the first argument by the second point (treating a point as being a complex number represented by real and imaginary parts, and performing standard complex multiplication). If one interprets the second point as a vector, this is equivalent to scaling the object's size and distance from the origin by the length of the vector, and rotating it counterclockwise around the origin by the vector's angle from the x axis. Available for point, box,[a] path, circle.
geometric_type / point → geometric_type				:geometric_type / point					:Divides each point of the first argument by the second point (treating a point as being a complex number represented by real and imaginary parts, and performing standard complex division). If one interprets the second point as a vector, this is equivalent to scaling the object's size and distance from the origin down by the length of the vector, and rotating it clockwise around the origin by the vector's angle from the x axis. Available for point, box,[a] path, circle.
@-@ geometric_type → double precision				:@-@ geometric_type						:Computes the total length. Available for lseg, path.
@@ geometric_type → point							:@@ geometric_type						:Computes the center point. Available for box, lseg, polygon, circle.
# geometric_type → integer							:# geometric_type						:Returns the number of points. Available for path, polygon.
geometric_type # geometric_type → point				:geometric_type # geometric_type		:Computes the point of intersection, or NULL if there is none. Available for lseg, line.
box # box → box										:box # box								:Computes the intersection of two boxes, or NULL if there is none.
geometric_type ## geometric_type → point			:geometric_type ## geometric_type 		:Computes the closest point to the first object on the second object. Available for these pairs of types: (point, box), (point, lseg), (point, line), (lseg, box), (lseg, lseg), (line, lseg).
geometric_type <-> geometric_type → double precision:geometric_type <-> geometric_type		:Computes the distance between the objects. Available for all seven geometric types, for all combinations of point with another geometric type, and for these additional pairs of types: (box, lseg), (lseg, line), (polygon, circle) (and the commutator cases).
geometric_type @> geometric_type → boolean			:geometric_type @> geometric_type 		:Does first object contain second? Available for these pairs of types: (box, point), (box, box), (path, point), (polygon, point), (polygon, polygon), (circle, point), (circle, circle).
geometric_type <@ geometric_type → boolean			:geometric_type <@ geometric_type 		:Is first object contained in or on second? Available for these pairs of types: (point, box), (point, lseg), (point, line), (point, path), (point, polygon), (point, circle), (box, box), (lseg, box), (lseg, line), (polygon, polygon), (circle, circle).
geometric_type && geometric_type → boolean			:geometric_type && geometric_type 		:Do these objects overlap? (One point in common makes this true.) Available for box, polygon, circle.
geometric_type << geometric_type → boolean			:geometric_type << geometric_type 		:Is first object strictly left of second? Available for point, box, polygon, circle.
geometric_type >> geometric_type → boolean			:geometric_type >> geometric_type 		:Is first object strictly right of second? Available for point, box, polygon, circle.
geometric_type &< geometric_type → boolean			:geometric_type &< geometric_type 		:Does first object not extend to the right of second? Available for box, polygon, circle.
geometric_type &> geometric_type → boolean			:geometric_type &> geometric_type 		:Does first object not extend to the left of second? Available for box, polygon, circle.
geometric_type <<| geometric_type → boolean			:geometric_type <<| geometric_type		:Is first object strictly below second? Available for point, box, polygon, circle.
geometric_type |>> geometric_type → boolean			:geometric_type |>> geometric_type		:Is first object strictly above second? Available for point, box, polygon, circle.
geometric_type &<| geometric_type → boolean			:geometric_type &<| geometric_type		:Does first object not extend above second? Available for box, polygon, circle.
geometric_type |&> geometric_type → boolean			:geometric_type |&> geometric_type		:Does first object not extend below second? Available for box, polygon, circle.
box <^ box → boolean								:box <^ box								:Is first object below second (allows edges to touch)?
box >^ box → boolean								:box >^ box								:Is first object above second (allows edges to touch)?
geometric_type ?# geometric_type → boolean			:geometric_type ?# geometric_type		:Do these objects intersect? Available for these pairs (box, box), (lseg, box), (lseg, lseg), (lseg, line), (line, box), (line, line), (path, path).
?- line → boolean									:?- line 						        :Is line horizontal?
?- lseg → boolean									:?- lseg 						        :Is line horizontal?
point ?- point → boolean							:point ?- point							:Are points horizontally aligned (that is, have same y coordinate)?
?| line → boolean									:?| line 						        :Is line vertical?
?| lseg → boolean									:?| lseg 						        :Is line vertical?
point ?| point → boolean							:point ?| point 				        :Are points vertically aligned (that is, have same x coordinate)?
line ?-| line → boolean								:line ?-| line 				            :Are lines perpendicular?
lseg ?-| lseg → boolean								:lseg ?-| lseg 				            :Are lines perpendicular?
line ?|| line → boolean								:line ?|| line 				            :Are lines parallel?
lseg ?|| lseg → boolean								:lseg ?|| lseg 				            :Are lines parallel?
geometric_type ~= geometric_type → boolean			:geometric_type ~= geometric_type		:Are these objects the same? Available for point, box, polygon, circle.
[-->Geometric Functions]
area ( geometric_type ) → double precision	:area ( geometric_type )		:Computes area. Available for box, path, circle. A path input must be closed, else NULL is returned. Also, if the path is self-intersecting, the result may be meaningless.
center ( geometric_type ) → point			:center ( geometric_type )		:Computes center point. Available for box, circle.
diagonal ( box ) → lseg						:diagonal ( box )				:Extracts box's diagonal as a line segment (same as lseg(box)).
diameter ( circle ) → double precision		:diameter ( circle )			:Computes diameter of circle.
height ( box ) → double precision			:height ( box )					:Computes vertical size of box.
isclosed ( path ) → boolean					:isclosed ( path )				:Is path closed?
isopen ( path ) → boolean					:isopen ( path )				:Is path open?
length ( geometric_type ) → double precision:length ( geometric_type )		:Computes the total length. Available for lseg, path.
npoints ( geometric_type ) → integer		:npoints ( geometric_type )		:Returns the number of points. Available for path, polygon.
pclose ( path ) → path						:pclose ( path )				:Converts path to closed form.
popen ( path ) → path						:popen ( path )					:Converts path to open form.
radius ( circle ) → double precision		:radius ( circle )				:Computes radius of circle.
slope ( point, point ) → double precision	:slope ( point, point )			:Computes slope of a line drawn through the two points.
width ( box ) → double precision			:width ( box )					:Computes horizontal size of box.
[-->Geometric Type Conversion Functions]
box ( circle ) → box                            :box ( circle )                     :Computes box inscribed within the circle.
box ( point ) → box                             :box ( point )                      :Converts point to empty box.
box ( point, point ) → box                      :box ( point, point )               :Converts any two corner points to box.
box ( polygon ) → box                           :box ( polygon )                    :Computes bounding box of polygon.
bound_box ( box, box ) → box                    :bound_box ( box, box )             :Computes bounding box of two boxes.
circle ( box ) → circle                         :circle ( box )                     :Computes smallest circle enclosing box.
circle ( point, double precision ) → circle     :circle ( point, double precision ) :Constructs circle from center and radius.
circle ( polygon ) → circle                     :circle ( polygon )                 :Converts polygon to circle. The circle's center is the mean of the positions of the polygon's points, and the radius is the average distance of the polygon's points from that center.
line ( point, point ) → line                    :line ( point, point )              :Converts two points to the line through them.
lseg ( box ) → lseg                             :lseg ( box )                       :Extracts box's diagonal as a line segment.
lseg ( point, point ) → lseg                    :lseg ( point, point )              :Constructs line segment from two endpoints.
path ( polygon ) → path                         :path ( polygon )                   :Converts polygon to a closed path with the same list of points.
point ( double precision, double precision ) → point:point ( double precision, double precision ) :Constructs point from its coordinates.
point ( box ) → point                           :point ( box )                      :Computes center of box.
point ( circle ) → point                        :point ( circle )                   :Computes center of circle.
point ( lseg ) → point                          :point ( lseg )                     :Computes center of line segment.
point ( polygon ) → point                       :point ( polygon )                  :Computes center of polygon (the mean of the positions of the polygon's points).
polygon ( box ) → polygon                       :polygon ( box )                    :Converts box to a 4-point polygon.
polygon ( circle ) → polygon                    :polygon ( circle )                 :Converts circle to a 12-point polygon.
polygon ( integer, circle ) → polygon           :polygon ( integer, circle )        :Converts circle to an n-point polygon.
polygon ( path ) → polygon                      :polygon ( path )                   :Converts closed path to a polygon with the same list of points.
[Network Address Functions and Operators]
[-->IP Address Operators]
inet << inet → boolean:inet << inet :Is subnet strictly contained by subnet? This operator, and the next four, test for subnet inclusion. They consider only the network parts of the two addresses (ignoring any bits to the right of the netmasks) and determine whether one network is identical to or a subnet of the other.
inet <<= inet → boolean:inet <<= inet :Is subnet contained by or equal to subnet?
inet >> inet → boolean:inet >> inet :Does subnet strictly contain subnet?
inet >>= inet → boolean:inet >>= inet :Does subnet contain or equal subnet?
inet && inet → boolean:inet && inet :Does either subnet contain or equal the other?
~ inet → inet:~ inet :Computes bitwise NOT.
inet & inet → inet:inet & inet :Computes bitwise AND.
inet | inet → inet:inet | inet :Computes bitwise OR.
inet + bigint → inet:inet + bigint :Adds an offset to an address.
bigint + inet → inet:bigint + inet :Adds an offset to an address.
inet - bigint → inet:inet - bigint :Subtracts an offset from an address.
inet - inet → bigint:inet - inet :Computes the difference of two addresses.
[-->IP Address Functions]
abbrev ( inet ) → text:abbrev ( ? ) :Creates an abbreviated display format as text. (The result is the same as the inet output function produces; it is “abbreviated” only in comparison to the result of an explicit cast to text, which for historical reasons will never suppress the netmask part.)
abbrev ( cidr ) → text:abbrev ( ? ) :Creates an abbreviated display format as text. (The abbreviation consists of dropping all-zero octets to the right of the netmask; more examples are in Table 8.22.)
broadcast ( inet ) → inet:broadcast ( ? ) :Computes the broadcast address for the address's network.
family ( inet ) → integer:family ( ? ) :Returns the address's family: 4 for IPv4, 6 for IPv6.
host ( inet ) → text:host ( ? ) :Returns the IP address as text, ignoring the netmask.
hostmask ( inet ) → inet:hostmask ( ? ) :Computes the host mask for the address's network.
inet_merge ( inet, inet ) → cidr:inet_merge ( ? ) :Computes the smallest network that includes both of the given networks.
inet_same_family ( inet, inet ) → boolean:inet_same_family ( ? ) :Tests whether the addresses belong to the same IP family.
masklen ( inet ) → integer:masklen ( ? ) :Returns the netmask length in bits.
netmask ( inet ) → inet:netmask ( ? ) :Computes the network mask for the address's network.
network ( inet ) → cidr:network ( ? ) :Returns the network part of the address, zeroing out whatever is to the right of the netmask. (This is equivalent to casting the value to cidr.)
set_masklen ( inet, integer ) → inet:set_masklen ( ? ) :Sets the netmask length for an inet value. The address part does not change.
set_masklen ( cidr, integer ) → cidr:set_masklen ( ? ) :Sets the netmask length for a cidr value. Address bits to the right of the new netmask are set to zero.
text ( inet ) → text:text ( ? ) :Returns the unabbreviated IP address and netmask length as text. (This has the same result as an explicit cast to text.)
[-->MAC Address Functions]
trunc ( macaddr ) → macaddr:trunc ( ? ) :Sets the last 3 bytes of the address to zero. The remaining prefix can be associated with a particular manufacturer (using data not included in PostgreSQL).
trunc ( macaddr8 ) → macaddr8:trunc ( ? ) :Sets the last 5 bytes of the address to zero. The remaining prefix can be associated with a particular manufacturer (using data not included in PostgreSQL).
macaddr8_set7bit ( macaddr8 ) → macaddr8:macaddr8_set7bit ( ? ) :Sets the 7th bit of the address to one, creating what is known as modified EUI-64, for inclusion in an IPv6 address.
[Text Search Functions and Operators]
[-->Text Search Operators]
tsquery @@ tsvector → boolean:tsquery @@ tsvector :Does tsvector match tsquery? (The arguments can be given in either order.)
tsvector @@ tsquery → boolean:tsvector @@ tsquery :Does tsvector match tsquery? (The arguments can be given in either order.)
text @@ tsquery → boolean:text @@ tsquery :Does text string, after implicit invocation of to_tsvector(), match tsquery?
tsvector @@@ tsquery → boolean:tsvector @@@ tsquery :This is a deprecated synonym for @@.
tsquery @@@ tsvector → boolean:tsquery @@@ tsvector :This is a deprecated synonym for @@.
tsvector || tsvector → tsvector:tsvector || tsvector :Concatenates two tsvectors. If both inputs contain lexeme positions, the second input's positions are adjusted accordingly.
tsquery && tsquery → tsquery:tsquery && tsquery :ANDs two tsquerys together, producing a query that matches documents that match both input queries.
tsquery || tsquery → tsquery:tsquery || tsquery :ORs two tsquerys together, producing a query that matches documents that match either input query.
!! tsquery → tsquery:!! tsquery :Negates a tsquery, producing a query that matches documents that do not match the input query.
tsquery <-> tsquery → tsquery:tsquery <-> tsquery :Constructs a phrase query, which matches if the two input queries match at successive lexemes.
tsquery @> tsquery → boolean:tsquery @> tsquery :Does first tsquery contain the second? (This considers only whether all the lexemes appearing in one query appear in the other, ignoring the combining operators.)
tsquery <@ tsquery → boolean:tsquery <@ tsquery :Is first tsquery contained in the second? (This considers only whether all the lexemes appearing in one query appear in the other, ignoring the combining operators.)
[-->Text Search Functions]
array_to_tsvector ( text[] ) → tsvector:array_to_tsvector ( ? ) :Converts an array of text strings to a tsvector. The given strings are used as lexemes as-is, without further processing. Array elements must not be empty strings or NULL.
get_current_ts_config ( ) → regconfig:get_current_ts_config ( ? ) :Returns the OID of the current default text search configuration (as set by default_text_search_config).
length ( tsvector ) → integer:length ( ? ) :Returns the number of lexemes in the tsvector.
numnode ( tsquery ) → integer:numnode ( ? ) :Returns the number of lexemes plus operators in the tsquery.
plainto_tsquery ( [ config regconfig, ] query text ) → tsquery:plainto_tsquery ( ? ) :Converts text to a tsquery, normalizing words according to the specified or default configuration. Any punctuation in the string is ignored (it does not determine query operators). The resulting query matches documents containing all non-stopwords in the text.
phraseto_tsquery ( [ config regconfig, ] query text ) → tsquery:phraseto_tsquery ( ? ) :Converts text to a tsquery, normalizing words according to the specified or default configuration. Any punctuation in the string is ignored (it does not determine query operators). The resulting query matches phrases containing all non-stopwords in the text.
websearch_to_tsquery ( [ config regconfig, ] query text ) → tsquery:websearch_to_tsquery ( ? ) :Converts text to a tsquery, normalizing words according to the specified or default configuration. Quoted word sequences are converted to phrase tests. The word “or” is understood as producing an OR operator, and a dash produces a NOT operator; other punctuation is ignored. This approximates the behavior of some common web search tools.
querytree ( tsquery ) → text:querytree ( ? ) :Produces a representation of the indexable portion of a tsquery. A result that is empty or just T indicates a non-indexable query.
setweight ( vector tsvector, weight "char" ) → tsvector:setweight ( ? ) :Assigns the specified weight to each element of the vector.
setweight ( vector tsvector, weight "char", lexemes text[] ) → tsvector:setweight ( ? ) :Assigns the specified weight to elements of the vector that are listed in lexemes. The strings in lexemes are taken as lexemes as-is, without further processing. Strings that do not match any lexeme in vector are ignored.
strip ( tsvector ) → tsvector:strip ( ? ) :Removes positions and weights from the tsvector.
to_tsquery ( [ config regconfig, ] query text ) → tsquery:to_tsquery ( ? ) :Converts text to a tsquery, normalizing words according to the specified or default configuration. The words must be combined by valid tsquery operators.
to_tsvector ( [ config regconfig, ] document text ) → tsvector:to_tsvector ( ? ) :Converts text to a tsvector, normalizing words according to the specified or default configuration. Position information is included in the result.
to_tsvector ( [ config regconfig, ] document jsonb ) → tsvector:to_tsvector ( ? ) :Converts each string value in the JSON document to a tsvector, normalizing words according to the specified or default configuration. The results are then concatenated in document order to produce the output. Position information is generated as though one stopword exists between each pair of string values. (Beware that “document order” of the fields of a JSON object is implementation-dependent when the input is jsonb; observe the difference in the examples.)
to_tsvector ( [ config regconfig, ] document json ) → tsvector:to_tsvector ( ? ) :Converts each string value in the JSON document to a tsvector, normalizing words according to the specified or default configuration. The results are then concatenated in document order to produce the output. Position information is generated as though one stopword exists between each pair of string values. (Beware that “document order” of the fields of a JSON object is implementation-dependent when the input is jsonb; observe the difference in the examples.)
json_to_tsvector ( [ config regconfig, ] document json, filter jsonb ) → tsvector:json_to_tsvector ( ? ) :Selects each item in the JSON document that is requested by the filter and converts each one to a tsvector, normalizing words according to the specified or default configuration. The results are then concatenated in document order to produce the output. Position information is generated as though one stopword exists between each pair of selected items. (Beware that “document order” of the fields of a JSON object is implementation-dependent when the input is jsonb.) The filter must be a jsonb array containing zero or more of these keywords: "string" (to include all string values), "numeric" (to include all numeric values), "boolean" (to include all boolean values), "key" (to include all keys), or "all" (to include all the above). As a special case, the filter can also be a simple JSON value that is one of these keywords.
jsonb_to_tsvector ( [ config regconfig, ] document jsonb, filter jsonb ) → tsvector:jsonb_to_tsvector ( ? ) :Selects each item in the JSON document that is requested by the filter and converts each one to a tsvector, normalizing words according to the specified or default configuration. The results are then concatenated in document order to produce the output. Position information is generated as though one stopword exists between each pair of selected items. (Beware that “document order” of the fields of a JSON object is implementation-dependent when the input is jsonb.) The filter must be a jsonb array containing zero or more of these keywords: "string" (to include all string values), "numeric" (to include all numeric values), "boolean" (to include all boolean values), "key" (to include all keys), or "all" (to include all the above). As a special case, the filter can also be a simple JSON value that is one of these keywords.
ts_delete ( vector tsvector, lexeme text ) → tsvector:ts_delete ( ? ) :Removes any occurrence of the given lexeme from the vector. The lexeme string is treated as a lexeme as-is, without further processing.
ts_delete ( vector tsvector, lexemes text[] ) → tsvector:ts_delete ( ? ) :Removes any occurrences of the lexemes in lexemes from the vector. The strings in lexemes are taken as lexemes as-is, without further processing. Strings that do not match any lexeme in vector are ignored.
ts_filter ( vector tsvector, weights "char"[] ) → tsvector:ts_filter ( ? ) :Selects only elements with the given weights from the vector.
ts_headline ( [ config regconfig, ] document text, query tsquery [, options text ] ) → text:ts_headline ( ? ) :Displays, in an abbreviated form, the match(es) for the query in the document, which must be raw text not a tsvector. Words in the document are normalized according to the specified or default configuration before matching to the query. Use of this function is discussed in Section 12.3.4, which also describes the available options.
ts_headline ( [ config regconfig, ] document json, query tsquery [, options text ] ) → text:ts_headline ( ? ) :Displays, in an abbreviated form, match(es) for the query that occur in string values within the JSON document. See Section 12.3.4 for more details.
ts_headline ( [ config regconfig, ] document jsonb, query tsquery [, options text ] ) → text:ts_headline ( ? ) :Displays, in an abbreviated form, match(es) for the query that occur in string values within the JSON document. See Section 12.3.4 for more details.
ts_rank ( [ weights real[], ] vector tsvector, query tsquery [, normalization integer ] ) → real:ts_rank ( ? ) :Computes a score showing how well the vector matches the query. See Section 12.3.3 for details.
ts_rank_cd ( [ weights real[], ] vector tsvector, query tsquery [, normalization integer ] ) → real:ts_rank_cd ( ? ) :Computes a score showing how well the vector matches the query, using a cover density algorithm. See Section 12.3.3 for details.
ts_rewrite ( query tsquery, target tsquery, substitute tsquery ) → tsquery:ts_rewrite ( ? ) :Replaces occurrences of target with substitute within the query. See Section 12.4.2.1 for details.
ts_rewrite ( query tsquery, select text ) → tsquery:ts_rewrite ( ? ) :Replaces portions of the query according to target(s) and substitute(s) obtained by executing a SELECT command. See Section 12.4.2.1 for details.
tsquery_phrase ( query1 tsquery, query2 tsquery ) → tsquery:tsquery_phrase ( ? ) :Constructs a phrase query that searches for matches of query1 and query2 at successive lexemes (same as <-> operator).
tsquery_phrase ( query1 tsquery, query2 tsquery, distance integer ) → tsquery:tsquery_phrase ( ? ) :Constructs a phrase query that searches for matches of query1 and query2 that occur exactly distance lexemes apart.
tsvector_to_array ( tsvector ) → text[]:tsvector_to_array ( ? ) :Converts a tsvector to an array of lexemes.
unnest ( tsvector ) → setof record ( lexeme text, positions smallint[], weights text ):unnest ( ? ) :Expands a tsvector into a set of rows, one per lexeme.
[-->Text Search Debugging Functions]
ts_debug ( [ config regconfig, ] document text ) → setof record ( alias text, description text, token text, dictionaries regdictionary[], dictionary regdictionary, lexemes text[] ):ts_debug ( ? ) :Extracts and normalizes tokens from the document according to the specified or default text search configuration, and returns information about how each token was processed. See Section 12.8.1 for details.
ts_lexize ( dict regdictionary, token text ) → text[]:ts_lexize ( ? ) :Returns an array of replacement lexemes if the input token is known to the dictionary, or an empty array if the token is known to the dictionary but it is a stop word, or NULL if it is not a known word. See Section 12.8.3 for details.
ts_parse ( parser_name text, document text ) → setof record ( tokid integer, token text ):ts_parse ( ? ) :Extracts tokens from the document using the named parser. See Section 12.8.2 for details.
ts_parse ( parser_oid oid, document text ) → setof record ( tokid integer, token text ):ts_parse ( ? ) :Extracts tokens from the document using a parser specified by OID. See Section 12.8.2 for details.
ts_token_type ( parser_name text ) → setof record ( tokid integer, alias text, description text ):ts_token_type ( ? ) :Returns a table that describes each type of token the named parser can recognize. See Section 12.8.2 for details.
ts_token_type ( parser_oid oid ) → setof record ( tokid integer, alias text, description text ):ts_token_type ( ? ) :Returns a table that describes each type of token a parser specified by OID can recognize. See Section 12.8.2 for details.
ts_stat ( sqlquery text [, weights text ] ) → setof record ( word text, ndoc integer, nentry integer ):ts_stat ( ? ) :Executes the sqlquery, which must return a single tsvector column, and returns statistics about each distinct lexeme contained in the data. See Section 12.4.4 for details.
[UUID Functions]
gen_random_uuid () → uuid:gen_random_uuid ( ? ) :This function returns a version 4 (random) UUID. This is the most commonly used type of UUID and is appropriate for most applications.
[XML Functions]
[-->Producing XML Content]
xmlcomment ( text ) → xml:xmlcomment ( ? ) :The function xmlcomment creates an XML value containing an XML comment with the specified text as content. The text cannot contain “--” or end with a “-”, otherwise the resulting construct would not be a valid XML comment. If the argument is null, the result is null.
xmlconcat ( xml [, ...] ) → xml:xmlconcat ( xml [, ...] ) :The function xmlconcat concatenates a list of individual XML values to create a single value containing an XML content fragment. Null values are omitted; the result is only null if there are no nonnull arguments.
xmlelement ( NAME name [, XMLATTRIBUTES ( attvalue [ AS attname ] [, ...] ) ] [, content [, ...]] ) → xml:xmlelement ( NAME name [, XMLATTRIBUTES ( attvalue [ AS attname ] [, ...] ) ] [, content [, ...]] ) :The xmlelement expression produces an XML element with the given name, attributes, and content. The name and attname items shown in the syntax are simple identifiers, not values. The attvalue and content items are expressions, which can yield any PostgreSQL data type. The argument(s) within XMLATTRIBUTES generate attributes of the XML element; the content value(s) are concatenated to form its content.
xmlforest ( content [ AS name ] [, ...] ) → xml:xmlforest ( content [ AS name ] [, ...] ) :The xmlforest expression produces an XML forest (sequence) of elements using the given names and content. As for xmlelement, each name must be a simple identifier, while the content expressions can have any data type.
xmlpi ( NAME name [, content ] ) → xml:xmlpi ( NAME name [, content ] ) :The xmlpi expression creates an XML processing instruction. As for xmlelement, the name must be a simple identifier, while the content expression can have any data type. The content, if present, must not contain the character sequence ?>.
xmlroot ( xml, VERSION {text|NO VALUE} [, STANDALONE {YES|NO|NO VALUE} ] ) → xml:xmlroot ( xml, VERSION {text|NO VALUE} [, STANDALONE {YES|NO|NO VALUE} ] ) :The xmlroot expression alters the properties of the root node of an XML value. If a version is specified, it replaces the value in the root node's version declaration; if a standalone setting is specified, it replaces the value in the root node's standalone declaration.
xmlagg ( xml ) → xml:xmlagg ( ? ) :The function xmlagg is, unlike the other functions described here, an aggregate function. It concatenates the input values to the aggregate function call, much like xmlconcat does, except that concatenation occurs across rows rather than across expressions in a single row. See Section 9.21 for additional information about aggregate functions.
[-->XML Predicates]
xml IS DOCUMENT → boolean:xml IS DOCUMENT :The expression IS DOCUMENT returns true if the argument XML value is a proper XML document, false if it is not (that is, it is a content fragment), or null if the argument is null. See Section 8.13 about the difference between documents and content fragments.
xml IS NOT DOCUMENT → boolean:xml IS NOT DOCUMENT :The expression IS NOT DOCUMENT returns false if the argument XML value is a proper XML document, true if it is not (that is, it is a content fragment), or null if the argument is null.
XMLEXISTS ( text PASSING [BY {REF|VALUE}] xml [BY {REF|VALUE}] ) → boolean:XMLEXISTS ( ? ) :The function xmlexists evaluates an XPath 1.0 expression (the first argument), with the passed XML value as its context item. The function returns false if the result of that evaluation yields an empty node-set, true if it yields any other value. The function returns null if any argument is null. A nonnull value passed as the context item must be an XML document, not a content fragment or any non-XML value.
xml_is_well_formed_content ( text ) → boolean:xml_is_well_formed_content ( ? ) :These functions check whether a text string represents well-formed XML, returning a Boolean result. xml_is_well_formed_document checks for a well-formed document, while xml_is_well_formed_content checks for well-formed content. xml_is_well_formed does the former if the xmloption configuration parameter is set to DOCUMENT, or the latter if it is set to CONTENT. This means that xml_is_well_formed is useful for seeing whether a simple cast to type xml will succeed, whereas the other two functions are useful for seeing whether the corresponding variants of XMLPARSE will succeed.
xml_is_well_formed ( text ) → boolean:xml_is_well_formed ( ? ) :These functions check whether a text string represents well-formed XML, returning a Boolean result. xml_is_well_formed_document checks for a well-formed document, while xml_is_well_formed_content checks for well-formed content. xml_is_well_formed does the former if the xmloption configuration parameter is set to DOCUMENT, or the latter if it is set to CONTENT. This means that xml_is_well_formed is useful for seeing whether a simple cast to type xml will succeed, whereas the other two functions are useful for seeing whether the corresponding variants of XMLPARSE will succeed.
xml_is_well_formed_document ( text ) → boolean:xml_is_well_formed_document ( ? ) :These functions check whether a text string represents well-formed XML, returning a Boolean result. xml_is_well_formed_document checks for a well-formed document, while xml_is_well_formed_content checks for well-formed content. xml_is_well_formed does the former if the xmloption configuration parameter is set to DOCUMENT, or the latter if it is set to CONTENT. This means that xml_is_well_formed is useful for seeing whether a simple cast to type xml will succeed, whereas the other two functions are useful for seeing whether the corresponding variants of XMLPARSE will succeed.
[-->Processing XML]
xpath ( xpath text, xml xml [, nsarray text[] ] ) → xml[]:xpath ( xpath text, xml xml [, nsarray text[] ] ) :The function xpath evaluates the XPath 1.0 expression xpath (given as text) against the XML value xml. It returns an array of XML values corresponding to the node-set produced by the XPath expression. If the XPath expression returns a scalar value rather than a node-set, a single-element array is returned.
xpath_exists ( xpath text, xml xml [, nsarray text[] ] ) → boolean:xpath_exists ( xpath text, xml xml [, nsarray text[] ] ) :The function xpath_exists is a specialized form of the xpath function. Instead of returning the individual XML values that satisfy the XPath 1.0 expression, this function returns a Boolean indicating whether the query was satisfied or not (specifically, whether it produced any value other than an empty node-set). This function is equivalent to the XMLEXISTS predicate, except that it also offers support for a namespace mapping argument.
XMLTABLE ([ XMLNAMESPACES ( namespace_uri AS namespace_name [, ...] ), ] row_expression PASSING [BY {REF|VALUE}] document_expression [BY {REF|VALUE}] COLUMNS name { type [PATH column_expression] [DEFAULT default_expression] [NOT NULL | NULL] | FOR ORDINALITY } [, ...]) → setof record:XMLTABLE ([ XMLNAMESPACES ( namespace_uri AS namespace_name [, ...] ), ] row_expression PASSING [BY {REF|VALUE}] document_expression [BY {REF|VALUE}] COLUMNS name { type [PATH column_expression] [DEFAULT default_expression] [NOT NULL | NULL] | FOR ORDINALITY } [, ...]) :The xmltable expression produces a table based on an XML value, an XPath filter to extract rows, and a set of column definitions. Although it syntactically resembles a function, it can only appear as a table in a query's FROM clause.
[-->Mapping Tables to XML]
table_to_xml ( table regclass, nulls boolean,tableforest boolean, targetns text ) → xml:table_to_xml ( table regclass, nulls boolean,tableforest boolean, targetns text ) :table_to_xml maps the content of the named table, passed as parameter table. The regclass type accepts strings identifying tables using the usual notation, including optional schema qualification and double quotes (see Section 8.19 for details). query_to_xml executes the query whose text is passed as parameter query and maps the result set. cursor_to_xml fetches the indicated number of rows from the cursor specified by the parameter cursor. This variant is recommended if large tables have to be mapped, because the result value is built up in memory by each function.
query_to_xml ( query text, nulls boolean,tableforest boolean, targetns text ) → xml:query_to_xml ( query text, nulls boolean,tableforest boolean, targetns text ) :table_to_xml maps the content of the named table, passed as parameter table. The regclass type accepts strings identifying tables using the usual notation, including optional schema qualification and double quotes (see Section 8.19 for details). query_to_xml executes the query whose text is passed as parameter query and maps the result set. cursor_to_xml fetches the indicated number of rows from the cursor specified by the parameter cursor. This variant is recommended if large tables have to be mapped, because the result value is built up in memory by each function.
cursor_to_xml ( cursor refcursor, count integer, nulls boolean,tableforest boolean, targetns text ) → xml:cursor_to_xml ( cursor refcursor, count integer, nulls boolean,tableforest boolean, targetns text ) :table_to_xml maps the content of the named table, passed as parameter table. The regclass type accepts strings identifying tables using the usual notation, including optional schema qualification and double quotes (see Section 8.19 for details). query_to_xml executes the query whose text is passed as parameter query and maps the result set. cursor_to_xml fetches the indicated number of rows from the cursor specified by the parameter cursor. This variant is recommended if large tables have to be mapped, because the result value is built up in memory by each function.
[JSON Functions and Operators]
[-->Processing and Creating JSON Data]
json -> integer → json:json -> integer :Extracts n'th element of JSON array (array elements are indexed from zero, but negative integers count from the end).
jsonb -> integer → jsonb:jsonb -> integer :Extracts n'th element of JSON array (array elements are indexed from zero, but negative integers count from the end).
json -> text → json:json -> text :Extracts JSON object field with the given key.
jsonb -> text → jsonb:jsonb -> text :Extracts JSON object field with the given key.
json ->> integer → text:json ->> integer :Extracts n'th element of JSON array, as text.
jsonb ->> integer → text:jsonb ->> integer :Extracts n'th element of JSON array, as text.
json ->> text → text:json ->> text :Extracts JSON object field with the given key, as text.
jsonb ->> text → text:jsonb ->> text :Extracts JSON object field with the given key, as text.
json #> text[] → json:json #> text[] :Extracts JSON sub-object at the specified path, where path elements can be either field keys or array indexes.
jsonb #> text[] → jsonb:jsonb #> text[] :Extracts JSON sub-object at the specified path, where path elements can be either field keys or array indexes.
json #>> text[] → text:json #>> text[] :Extracts JSON sub-object at the specified path as text.
jsonb #>> text[] → text:jsonb #>> text[] :Extracts JSON sub-object at the specified path as text.
[-->Additional jsonb Operators]
jsonb @> jsonb → boolean:jsonb @> jsonb :Does the first JSON value contain the second? (See Section 8.14.3 for details about containment.)
jsonb <@ jsonb → boolean:jsonb <@ jsonb :Is the first JSON value contained in the second?
jsonb ? text → boolean:jsonb ? text :Does the text string exist as a top-level key or array element within the JSON value?
jsonb ?| text[] → boolean:jsonb ?| text[] :Do any of the strings in the text array exist as top-level keys or array elements?
jsonb ?& text[] → boolean:jsonb ?& text[] :Do all of the strings in the text array exist as top-level keys or array elements?
jsonb || jsonb → jsonb:jsonb || jsonb :Concatenates two jsonb values. Concatenating two arrays generates an array containing all the elements of each input. Concatenating two objects generates an object containing the union of their keys, taking the second object's value when there are duplicate keys. All other cases are treated by converting a non-array input into a single-element array, and then proceeding as for two arrays. Does not operate recursively: only the top-level array or object structure is merged.
jsonb - text → jsonb:jsonb - text :Deletes a key (and its value) from a JSON object, or matching string value(s) from a JSON array.
jsonb - text[] → jsonb:jsonb - text[] :Deletes all matching keys or array elements from the left operand.
jsonb - integer → jsonb:jsonb - integer :Deletes the array element with specified index (negative integers count from the end). Throws an error if JSON value is not an array.
jsonb #- text[] → jsonb:jsonb #- text[] :Deletes the field or array element at the specified path, where path elements can be either field keys or array indexes.
jsonb @? jsonpath → boolean:jsonb @? jsonpath :Does JSON path return any item for the specified JSON value?
jsonb @@ jsonpath → boolean:jsonb @@ jsonpath :Returns the result of a JSON path predicate check for the specified JSON value. Only the first item of the result is taken into account. If the result is not Boolean, then NULL is returned.
[-->JSON Creation Functions]
to_json ( anyelement ) → json:to_json ( ? ) :Converts any SQL value to json or jsonb. Arrays and composites are converted recursively to arrays and objects (multidimensional arrays become arrays of arrays in JSON). Otherwise, if there is a cast from the SQL data type to json, the cast function will be used to perform the conversion;[a] otherwise, a scalar JSON value is produced. For any scalar other than a number, a Boolean, or a null value, the text representation will be used, with escaping as necessary to make it a valid JSON string value.
to_jsonb ( anyelement ) → jsonb:to_jsonb ( ? ) :Converts any SQL value to json or jsonb. Arrays and composites are converted recursively to arrays and objects (multidimensional arrays become arrays of arrays in JSON). Otherwise, if there is a cast from the SQL data type to json, the cast function will be used to perform the conversion;[a] otherwise, a scalar JSON value is produced. For any scalar other than a number, a Boolean, or a null value, the text representation will be used, with escaping as necessary to make it a valid JSON string value.
array_to_json ( anyarray [, boolean ] ) → json:array_to_json ( anyarray [, boolean ] ) :Converts an SQL array to a JSON array. The behavior is the same as to_json except that line feeds will be added between top-level array elements if the optional boolean parameter is true.
row_to_json ( record [, boolean ] ) → json:row_to_json ( record [, boolean ] ) :Converts an SQL composite value to a JSON object. The behavior is the same as to_json except that line feeds will be added between top-level elements if the optional boolean parameter is true.
json_build_array ( VARIADIC "any" ) → json:json_build_array ( VARIADIC "any" ) :Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list. Each argument is converted as per to_json or to_jsonb.
jsonb_build_array ( VARIADIC "any" ) → jsonb:jsonb_build_array ( VARIADIC "any" ) :Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list. Each argument is converted as per to_json or to_jsonb.
json_build_object ( VARIADIC "any" ) → json:json_build_object ( VARIADIC "any" ) :Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values. Key arguments are coerced to text; value arguments are converted as per to_json or to_jsonb.
jsonb_build_object ( VARIADIC "any" ) → jsonb:jsonb_build_object ( VARIADIC "any" ) :Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values. Key arguments are coerced to text; value arguments are converted as per to_json or to_jsonb.
json_object ( text[] ) → json:json_object ( ? ) :Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair. All values are converted to JSON strings.
jsonb_object ( text[] ) → jsonb:jsonb_object ( ? ) :Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair. All values are converted to JSON strings.
json_object ( keys text[], values text[] ) → json:json_object ( keys text[], values text[] ) :This form of json_object takes keys and values pairwise from separate text arrays. Otherwise it is identical to the one-argument form.
jsonb_object ( keys text[], values text[] ) → jsonb:jsonb_object ( keys text[], values text[] ) :This form of json_object takes keys and values pairwise from separate text arrays. Otherwise it is identical to the one-argument form.
[-->JSON Processing Functions]
json_array_elements ( json ) → setof json:json_array_elements ( ? ) :Expands the top-level JSON array into a set of JSON values.
jsonb_array_elements ( jsonb ) → setof jsonb:jsonb_array_elements ( ? ) :Expands the top-level JSON array into a set of JSON values.
json_array_elements_text ( json ) → setof text:json_array_elements_text ( ? ) :Expands the top-level JSON array into a set of text values.
jsonb_array_elements_text ( jsonb ) → setof text:jsonb_array_elements_text ( ? ) :Expands the top-level JSON array into a set of text values.
json_array_length ( json ) → integer:json_array_length ( ? ) :Returns the number of elements in the top-level JSON array.
jsonb_array_length ( jsonb ) → integer:jsonb_array_length ( ? ) :Returns the number of elements in the top-level JSON array.
json_each ( json ) → setof record ( key text, value json ):json_each ( ? ) :Expands the top-level JSON object into a set of key/value pairs.
jsonb_each ( jsonb ) → setof record ( key text, value jsonb ):jsonb_each ( ? ) :Expands the top-level JSON object into a set of key/value pairs.
json_each_text ( json ) → setof record ( key text, value text ):json_each_text ( ? ) :Expands the top-level JSON object into a set of key/value pairs. The returned values will be of type text.
jsonb_each_text ( jsonb ) → setof record ( key text, value text ):jsonb_each_text ( ? ) :Expands the top-level JSON object into a set of key/value pairs. The returned values will be of type text.
json_extract_path ( from_json json, VARIADIC path_elems text[] ) → json:json_extract_path ( from_json json, VARIADIC path_elems text[] ) :Extracts JSON sub-object at the specified path. (This is functionally equivalent to the #> operator, but writing the path out as a variadic list can be more convenient in some cases.)
jsonb_extract_path ( from_json jsonb, VARIADIC path_elems text[] ) → jsonb:jsonb_extract_path ( from_json jsonb, VARIADIC path_elems text[] ) :Extracts JSON sub-object at the specified path. (This is functionally equivalent to the #> operator, but writing the path out as a variadic list can be more convenient in some cases.)
json_extract_path_text ( from_json json, VARIADIC path_elems text[] ) → text:json_extract_path_text ( from_json json, VARIADIC path_elems text[] ) :Extracts JSON sub-object at the specified path as text. (This is functionally equivalent to the #>> operator.)
jsonb_extract_path_text ( from_json jsonb, VARIADIC path_elems text[] ) → text:jsonb_extract_path_text ( from_json jsonb, VARIADIC path_elems text[] ) :Extracts JSON sub-object at the specified path as text. (This is functionally equivalent to the #>> operator.)
json_object_keys ( json ) → setof text:json_object_keys ( ? ) :Returns the set of keys in the top-level JSON object.
jsonb_object_keys ( jsonb ) → setof text:jsonb_object_keys ( ? ) :Returns the set of keys in the top-level JSON object.
json_populate_record ( base anyelement, from_json json ) → anyelement:json_populate_record ( base anyelement, from_json json ) :Expands the top-level JSON object to a row having the composite type of the base argument. The JSON object is scanned for fields whose names match column names of the output row type, and their values are inserted into those columns of the output. (Fields that do not correspond to any output column name are ignored.) In typical use, the value of base is just NULL, which means that any output columns that do not match any object field will be filled with nulls. However, if base isn't NULL then the values it contains will be used for unmatched columns.
jsonb_populate_record ( base anyelement, from_json jsonb ) → anyelement:jsonb_populate_record ( base anyelement, from_json jsonb ) :Expands the top-level JSON object to a row having the composite type of the base argument. The JSON object is scanned for fields whose names match column names of the output row type, and their values are inserted into those columns of the output. (Fields that do not correspond to any output column name are ignored.) In typical use, the value of base is just NULL, which means that any output columns that do not match any object field will be filled with nulls. However, if base isn't NULL then the values it contains will be used for unmatched columns.
json_populate_recordset ( base anyelement, from_json json ) → setof anyelement:json_populate_recordset ( base anyelement, from_json json ) :Expands the top-level JSON array of objects to a set of rows having the composite type of the base argument. Each element of the JSON array is processed as described above for json[b]_populate_record.
jsonb_populate_recordset ( base anyelement, from_json jsonb ) → setof anyelement:jsonb_populate_recordset ( base anyelement, from_json jsonb ) :Expands the top-level JSON array of objects to a set of rows having the composite type of the base argument. Each element of the JSON array is processed as described above for json[b]_populate_record.
json_to_record ( json ) → record:json_to_record ( ? ) :Expands the top-level JSON object to a row having the composite type defined by an AS clause. (As with all functions returning record, the calling query must explicitly define the structure of the record with an AS clause.) The output record is filled from fields of the JSON object, in the same way as described above for json[b]_populate_record. Since there is no input record value, unmatched columns are always filled with nulls.
jsonb_to_record ( jsonb ) → record:jsonb_to_record ( ? ) :Expands the top-level JSON object to a row having the composite type defined by an AS clause. (As with all functions returning record, the calling query must explicitly define the structure of the record with an AS clause.) The output record is filled from fields of the JSON object, in the same way as described above for json[b]_populate_record. Since there is no input record value, unmatched columns are always filled with nulls.
json_to_recordset ( json ) → setof record:json_to_recordset ( ? ) :Expands the top-level JSON array of objects to a set of rows having the composite type defined by an AS clause. (As with all functions returning record, the calling query must explicitly define the structure of the record with an AS clause.) Each element of the JSON array is processed as described above for json[b]_populate_record.
jsonb_to_recordset ( jsonb ) → setof record:jsonb_to_recordset ( ? ) :Expands the top-level JSON array of objects to a set of rows having the composite type defined by an AS clause. (As with all functions returning record, the calling query must explicitly define the structure of the record with an AS clause.) Each element of the JSON array is processed as described above for json[b]_populate_record.
jsonb_set ( target jsonb, path text[], new_value jsonb [, create_if_missing boolean ] ) → jsonb:jsonb_set ( target jsonb, path text[], new_value jsonb [, create_if_missing boolean ] ) :Returns target with the item designated by path replaced by new_value, or with new_value added if create_if_missing is true (which is the default) and the item designated by path does not exist. All earlier steps in the path must exist, or the target is returned unchanged. As with the path oriented operators, negative integers that appear in the path count from the end of JSON arrays. If the last path step is an array index that is out of range, and create_if_missing is true, the new value is added at the beginning of the array if the index is negative, or at the end of the array if it is positive.
jsonb_set_lax ( target jsonb, path text[], new_value jsonb [, create_if_missing boolean [, null_value_treatment text ]] ) → jsonb:jsonb_set_lax ( target jsonb, path text[], new_value jsonb [, create_if_missing boolean [, null_value_treatment text ]] ) :If new_value is not NULL, behaves identically to jsonb_set. Otherwise behaves according to the value of null_value_treatment which must be one of 'raise_exception', 'use_json_null', 'delete_key', or 'return_target'. The default is 'use_json_null'.
jsonb_insert ( target jsonb, path text[], new_value jsonb [, insert_after boolean ] ) → jsonb:jsonb_insert ( target jsonb, path text[], new_value jsonb [, insert_after boolean ] ) :Returns target with new_value inserted. If the item designated by the path is an array element, new_value will be inserted before that item if insert_after is false (which is the default), or after it if insert_after is true. If the item designated by the path is an object field, new_value will be inserted only if the object does not already contain that key. All earlier steps in the path must exist, or the target is returned unchanged. As with the path oriented operators, negative integers that appear in the path count from the end of JSON arrays. If the last path step is an array index that is out of range, the new value is added at the beginning of the array if the index is negative, or at the end of the array if it is positive.
json_strip_nulls ( json ) → json:json_strip_nulls ( ? ) :Deletes all object fields that have null values from the given JSON value, recursively. Null values that are not object fields are untouched.
jsonb_strip_nulls ( jsonb ) → jsonb:jsonb_strip_nulls ( ? ) :Deletes all object fields that have null values from the given JSON value, recursively. Null values that are not object fields are untouched.
jsonb_path_exists ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) → boolean:jsonb_path_exists ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) :Checks whether the JSON path returns any item for the specified JSON value. If the vars argument is specified, it must be a JSON object, and its fields provide named values to be substituted into the jsonpath expression. If the silent argument is specified and is true, the function suppresses the same errors as the @? and @@ operators do.
jsonb_path_match ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) → boolean:jsonb_path_match ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) :Returns the result of a JSON path predicate check for the specified JSON value. Only the first item of the result is taken into account. If the result is not Boolean, then NULL is returned. The optional vars and silent arguments act the same as for jsonb_path_exists.
jsonb_path_query ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) → setof jsonb:jsonb_path_query ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) :Returns all JSON items returned by the JSON path for the specified JSON value. The optional vars and silent arguments act the same as for jsonb_path_exists.
jsonb_path_query_array ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) → jsonb:jsonb_path_query_array ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) :Returns all JSON items returned by the JSON path for the specified JSON value, as a JSON array. The optional vars and silent arguments act the same as for jsonb_path_exists.
jsonb_path_query_first ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) → jsonb:jsonb_path_query_first ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) :Returns the first JSON item returned by the JSON path for the specified JSON value. Returns NULL if there are no results. The optional vars and silent arguments act the same as for jsonb_path_exists.
jsonb_path_exists_tz ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) → boolean:jsonb_path_exists_tz ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) :These functions act like their counterparts described above without the _tz suffix, except that these functions support comparisons of date/time values that require timezone-aware conversions. The example below requires interpretation of the date-only value 2015-08-02 as a timestamp with time zone, so the result depends on the current TimeZone setting. Due to this dependency, these functions are marked as stable, which means these functions cannot be used in indexes. Their counterparts are immutable, and so can be used in indexes; but they will throw errors if asked to make such comparisons.
jsonb_path_match_tz ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) → boolean:jsonb_path_match_tz ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) :These functions act like their counterparts described above without the _tz suffix, except that these functions support comparisons of date/time values that require timezone-aware conversions. The example below requires interpretation of the date-only value 2015-08-02 as a timestamp with time zone, so the result depends on the current TimeZone setting. Due to this dependency, these functions are marked as stable, which means these functions cannot be used in indexes. Their counterparts are immutable, and so can be used in indexes; but they will throw errors if asked to make such comparisons.
jsonb_path_query_tz ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) → setof jsonb:jsonb_path_query_tz ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) :These functions act like their counterparts described above without the _tz suffix, except that these functions support comparisons of date/time values that require timezone-aware conversions. The example below requires interpretation of the date-only value 2015-08-02 as a timestamp with time zone, so the result depends on the current TimeZone setting. Due to this dependency, these functions are marked as stable, which means these functions cannot be used in indexes. Their counterparts are immutable, and so can be used in indexes; but they will throw errors if asked to make such comparisons.
jsonb_path_query_array_tz ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) → jsonb:jsonb_path_query_array_tz ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) :These functions act like their counterparts described above without the _tz suffix, except that these functions support comparisons of date/time values that require timezone-aware conversions. The example below requires interpretation of the date-only value 2015-08-02 as a timestamp with time zone, so the result depends on the current TimeZone setting. Due to this dependency, these functions are marked as stable, which means these functions cannot be used in indexes. Their counterparts are immutable, and so can be used in indexes; but they will throw errors if asked to make such comparisons.
jsonb_path_query_first_tz ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) → jsonb:jsonb_path_query_first_tz ( target jsonb, path jsonpath [, vars jsonb [, silent boolean ]] ) :These functions act like their counterparts described above without the _tz suffix, except that these functions support comparisons of date/time values that require timezone-aware conversions. The example below requires interpretation of the date-only value 2015-08-02 as a timestamp with time zone, so the result depends on the current TimeZone setting. Due to this dependency, these functions are marked as stable, which means these functions cannot be used in indexes. Their counterparts are immutable, and so can be used in indexes; but they will throw errors if asked to make such comparisons.
jsonb_pretty ( jsonb ) → text:jsonb_pretty ( ? ) :Converts the given JSON value to pretty-printed, indented text.
json_typeof ( json ) → text:json_typeof ( ? ) :Returns the type of the top-level JSON value as a text string. Possible types are object, array, string, number, boolean, and null. (The null result should not be confused with an SQL NULL; see the examples.)
jsonb_typeof ( jsonb ) → text:jsonb_typeof ( ? ) :Returns the type of the top-level JSON value as a text string. Possible types are object, array, string, number, boolean, and null. (The null result should not be confused with an SQL NULL; see the examples.)
[-->SQL/JSON Path Operators And Methods]
number + number → number:number + number :Addition
+ number → number:+ number :Unary plus (no operation); unlike addition, this can iterate over multiple values
number - number → number:number - number :Subtraction
- number → number:- number :Negation; unlike subtraction, this can iterate over multiple values
number * number → number:number * number :Multiplication
number / number → number:number / number :Division
number % number → number:number % number :Modulo (remainder)
value . type() → string:value . type() :Type of the JSON item (see json_typeof)
value . size() → number:value . size() :Size of the JSON item (number of array elements, or 1 if not an array)
value . double() → number:value . double() :Approximate floating-point number converted from a JSON number or string
number . ceiling() → number:number . ceiling() :Nearest integer greater than or equal to the given number
number . floor() → number:number . floor() :Nearest integer less than or equal to the given number
number . abs() → number:number . abs() :Absolute value of the given number
string . datetime() → datetime_type (see note):string . datetime() :Date/time value converted from a string
string . datetime(template) → datetime_type (see note):string . datetime( ? ) :Date/time value converted from a string using the specified to_timestamp template
object . keyvalue() → array:object . keyvalue() :The object's key-value pairs, represented as an array of objects containing three fields: "key", "value", and "id"; "id" is a unique identifier of the object the key-value pair belongs to
[-->jsonpath Filter Expression Elements]
value == value → boolean:value == value :Equality comparison (this, and the other comparison operators, work on all JSON scalar values)
value != value → boolean:value != value :Non-equality comparison
value <> value → boolean:value <> value :Non-equality comparison
value < value → boolean:value < value :Less-than comparison
value <= value → boolean:value <= value :Less-than-or-equal-to comparison
value > value → boolean:value > value :Greater-than comparison
value >= value → boolean:value >= value :Greater-than-or-equal-to comparison
true → boolean:true :JSON constant true
false → boolean:false :JSON constant false
null → value:null :JSON constant null (note that, unlike in SQL, comparison to null works normally)
boolean && boolean → boolean:boolean && boolean :Boolean AND
boolean || boolean → boolean:boolean || boolean :Boolean OR
! boolean → boolean:! boolean :Boolean NOT
boolean is unknown → boolean:boolean is unknown :Tests whether a Boolean condition is unknown.
string like_regex string [ flag string ] → boolean:string like_regex string [ flag string ] :Tests whether the first operand matches the regular expression given by the second operand, optionally with modifications described by a string of flag characters (see Section 9.16.2.3).
string starts with string → boolean:string starts with string :Tests whether the second operand is an initial substring of the first operand.
exists ( path_expression ) → boolean:exists ( ? ) :Tests whether a path expression matches at least one SQL/JSON item. Returns unknown if the path expression would result in an error; the second example uses this to avoid a no-such-key error in strict mode.
[Sequence Manipulation Functions]









