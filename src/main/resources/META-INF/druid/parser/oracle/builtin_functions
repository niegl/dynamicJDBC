[Arithmetic Operators]
-sign   : - ?   : Change the sign of the argument
+sign   : + ?   : Change the sign of the argument
+       :? + ?  : Addition operator
-       :? - ?  : Minus operator
*       :? * ?  : Multiplication operator
/       :? / ?  : Division operator
[COLLATE Operator]
COLLATE collation_name  :COLLATE collation_name :Determines the collation for an expression
[Concatenation Operator]
||  :A || B :Concatenates character strings and CLOB data.
[Set Operators]
UNION       :UNION       :All distinct rows selected by either query
UNION ALL   :UNION ALL   :All rows selected by either query, including all duplicates
INTERSECT   :INTERSECT   :All distinct rows selected by both queries
MINUS       :MINUS       :All distinct rows selected by the first query but not the second
[Multiset Operators]
MULTISET EXCEPT ALL             :MULTISET EXCEPT ALL nested_table2           :MULTISET EXCEPT takes as arguments two nested tables and returns a nested table whose elements are in the first nested table but not in the second nested table. The two input nested tables must be of the same type, and the returned nested table is of the same type as well.
MULTISET EXCEPT DISTINCT        :MULTISET EXCEPT DISTINCT nested_table2      :MULTISET EXCEPT takes as arguments two nested tables and returns a nested table whose elements are in the first nested table but not in the second nested table. The two input nested tables must be of the same type, and the returned nested table is of the same type as well.
MULTISET INTERSECT ALL          :MULTISET INTERSECT ALL nested_table2        :MULTISET INTERSECT takes as arguments two nested tables and returns a nested table whose values are common in the two input nested tables. The two input nested tables must be of the same type, and the returned nested table is of the same type as well.
MULTISET INTERSECT DISTINCT     :MULTISET INTERSECT DISTINCT nested_table2   :MULTISET INTERSECT takes as arguments two nested tables and returns a nested table whose values are common in the two input nested tables. The two input nested tables must be of the same type, and the returned nested table is of the same type as well.
MULTISET UNION ALL              :MULTISET UNION ALL nested_table2            :MULTISET UNION takes as arguments two nested tables and returns a nested table whose values are those of the two input nested tables. The two input nested tables must be of the same type, and the returned nested table is of the same type as well.
MULTISET UNION DISTINCT         :MULTISET UNION DISTINCT nested_table2       :MULTISET UNION takes as arguments two nested tables and returns a nested table whose values are those of the two input nested tables. The two input nested tables must be of the same type, and the returned nested table is of the same type as well.
[Comparison Conditions]
=       :A = B		:TRUE if expression A is equal to expression B otherwise FALSE.
<>      :A <> B		:NULL if A or B is NULL, TRUE if expression A is NOT equal to expression B, otherwise FALSE.
!=      :A != B		:Synonym for the <> operator.
^=      :A ^= B		:Synonym for the <> operator.
<       :A < B		:NULL if A or B is NULL, TRUE if expression A is less than expression B, otherwise FALSE.
<=      :A <= B		:NULL if A or B is NULL, TRUE if expression A is less than or equal to expression B, otherwise FALSE.
>       :A > B		:NULL if A or B is NULL, TRUE if expression A is greater than expression B, otherwise FALSE.
>=      :A >= B		:NULL if A or B is NULL, TRUE if expression A is greater than or equal to expression B, otherwise FALSE.
op ANY  :A op ANY (B)   :"op" must be one of =, !=, >, <, <=, or >=.  op ANY compares a value on the left side either to each value in a list, or to each value returned by a query, whichever is specified on the right side, using the condition op. If any of these comparisons returns TRUE, op ANY returns TRUE.If all of these comparisons return FALSE, or the subquery on the right side returns no rows, op ANY returns FALSE. Otherwise, the return value is UNKNOWN.
op SOME :A op SOME (B)  :"op" must be one of =, !=, >, <, <=, or >=.  op ANY compares a value on the left side either to each value in a list, or to each value returned by a query, whichever is specified on the right side, using the condition op. If any of these comparisons returns TRUE, op ANY returns TRUE.If all of these comparisons return FALSE, or the subquery on the right side returns no rows, op ANY returns FALSE. Otherwise, the return value is UNKNOWN.
op ALL  :A op ALL (B)   :"op" must be one of =, !=, >, <, <=, or >=.  op ALL compares a value on the left side either to each value in a list, or to each value returned by a subquery, whichever is specified on the right side, using the condition op.If any of these comparisons returns FALSE, op ANY returns FALSE.If all of these comparisons return TRUE, or the subquery on the right side returns no rows, op ALL returns TRUE . Otherwise, the return value is UNKNOWN.
[Floating-Point Conditions]
IS NAN              :? IS NAN               :Returns TRUE if expr is the special value NaN when NOT is not specified. Returns TRUE if expr is not the special value NaN when NOT is specified.
IS NOT NAN          :? IS NOT NAN           :Returns TRUE if expr is the special value NaN when NOT is not specified. Returns TRUE if expr is not the special value NaN when NOT is specified.
IS INFINITE         :? IS INFINITE          :Returns TRUE if expr is the special value +INF or -INF when NOT is not specified. Returns TRUE if expr is neither +INF nor -INF when NOT is specified.
IS NOT INFINITE     :? IS NOT INFINITE      :Returns TRUE if expr is the special value +INF or -INF when NOT is not specified. Returns TRUE if expr is neither +INF nor -INF when NOT is specified.
[Logical Conditions]
AND	    :A AND B	:TRUE if both A and B are TRUE, otherwise FALSE. NULL if A or B is NULL.
OR 	    :A OR B		:TRUE if either A or B or both are TRUE, FALSE OR NULL is NULL, otherwise FALSE.
NOT A	:NOT ?		:TRUE if A is FALSE or NULL if A is NULL. Otherwise FALSE.
[Model Conditions]
IS ANY Condition        :[dimension_column IS] ANY  :The IS ANY condition can be used only in the model_clause of a SELECT statement. Use this condition to qualify all values of a dimension column, including NULL.
IS PRESENT Condition    :cell_reference IS PRESENT  :The IS PRESENT condition can be used only in the model_clause of a SELECT statement. Use this condition to test whether the cell referenced is present prior to the execution of the model_clause.
[Multiset Conditions]
IS A SET Condition      :nested_table IS A SET          :Use IS A SET conditions to test whether a specified nested table is composed of unique elements. The condition returns UNKNOWN if the nested table is NULL. Otherwise, it returns TRUE if the nested table is a set, even if it is a nested table of length zero, and FALSE otherwise.
IS NOT A SET Condition  :nested_table IS NOT A SET Condition    :Use IS A SET conditions to test whether a specified nested table is composed of unique elements. The condition returns UNKNOWN if the nested table is NULL. Otherwise, it returns TRUE if the nested table is a set, even if it is a nested table of length zero, and FALSE otherwise.
IS EMPTY Condition      :nested_table IS EMPTY          :Use the IS [NOT] EMPTY conditions to test whether a specified nested table is empty. A nested table that consists of a single value, a NULL, is not considered an empty nested table.
IS NOT EMPTY Condition  :nested_table IS NOT EMPTY      :Use the IS [NOT] EMPTY conditions to test whether a specified nested table is empty. A nested table that consists of a single value, a NULL, is not considered an empty nested table.
MEMBER Condition        :expr MEMBER OF nested_table    :A member_condition is a membership condition that tests whether an element is a member of a nested table. The return value is TRUE if expr is equal to a member of the specified nested table or varray. The return value is NULL if expr is null or if the nested table is empty.
NOT MEMBER Condition    :expr NOT MEMBER OF nested_table    :A member_condition is a membership condition that tests whether an element is a member of a nested table. The return value is TRUE if expr is equal to a member of the specified nested table or varray. The return value is NULL if expr is null or if the nested table is empty.
SUBMULTISET Condition   :nested_table1 SUBMULTISET OF nested_table2 :The SUBMULTISET condition tests whether a specified nested table is a submultiset of another specified nested table.
NOT SUBMULTISET Condition   :nested_table1 NOT SUBMULTISET OF nested_table2 :The SUBMULTISET condition tests whether a specified nested table is a submultiset of another specified nested table.
[Pattern-matching Conditions]
x LIKE y        :x LIKE y [ESCAPE 'z']      :TRUE if x does [not] match the pattern y. Within y, the character % matches any string of zero or more characters except null. The character _ matches any single character. Any character can follow ESCAPE except percent (%) and underbar (_). A wildcard character is treated as a literal if preceded by the escape character.
x NOT LIKE y    :x NOT LIKE y [ESCAPE 'z']  :TRUE if x does [not] match the pattern y. Within y, the character % matches any string of zero or more characters except null. The character _ matches any single character. Any character can follow ESCAPE except percent (%) and underbar (_). A wildcard character is treated as a literal if preceded by the escape character.
x LIKEC y       :x LIKEC y [ESCAPE 'z']      :TRUE if x does [not] match the pattern y. Within y, the character % matches any string of zero or more characters except null. The character _ matches any single character. Any character can follow ESCAPE except percent (%) and underbar (_). A wildcard character is treated as a literal if preceded by the escape character.
x NOT LIKEC y   :x NOT LIKEC y [ESCAPE 'z']  :TRUE if x does [not] match the pattern y. Within y, the character % matches any string of zero or more characters except null. The character _ matches any single character. Any character can follow ESCAPE except percent (%) and underbar (_). A wildcard character is treated as a literal if preceded by the escape character.
x LIKE2 y       :x LIKE2 y [ESCAPE 'z']      :TRUE if x does [not] match the pattern y. Within y, the character % matches any string of zero or more characters except null. The character _ matches any single character. Any character can follow ESCAPE except percent (%) and underbar (_). A wildcard character is treated as a literal if preceded by the escape character.
x NOT LIKE2 y   :x NOT LIKE2 y [ESCAPE 'z']  :TRUE if x does [not] match the pattern y. Within y, the character % matches any string of zero or more characters except null. The character _ matches any single character. Any character can follow ESCAPE except percent (%) and underbar (_). A wildcard character is treated as a literal if preceded by the escape character.
x LIKE4 y       :x LIKE4 y [ESCAPE 'z']      :TRUE if x does [not] match the pattern y. Within y, the character % matches any string of zero or more characters except null. The character _ matches any single character. Any character can follow ESCAPE except percent (%) and underbar (_). A wildcard character is treated as a literal if preceded by the escape character.
x NOT LIKE4 y   :x NOT LIKE4 y [ESCAPE 'z']  :TRUE if x does [not] match the pattern y. Within y, the character % matches any string of zero or more characters except null. The character _ matches any single character. Any character can follow ESCAPE except percent (%) and underbar (_). A wildcard character is treated as a literal if preceded by the escape character.
REGEXP_LIKE     :REGEXP_LIKE (source_char, pattern)   :REGEXP_LIKE is similar to the LIKE condition, except REGEXP_LIKE performs regular expression matching instead of the simple pattern matching performed by LIKE. This condition evaluates strings using characters as defined by the input character set.
REGEXP_LIKE (match_param)   :REGEXP_LIKE (source_char, pattern, match_param)    :REGEXP_LIKE is similar to the LIKE condition, except REGEXP_LIKE performs regular expression matching instead of the simple pattern matching performed by LIKE. This condition evaluates strings using characters as defined by the input character set.
[Null Conditions]
IS NULL         :expr IS NULL       :A NULL condition tests for nulls. This is the only condition that you should use to test for nulls.
IS NOT NULL     :expr IS NOT NULL   :A NULL condition tests for nulls. This is the only condition that you should use to test for nulls.
[XML Conditions]
EQUALS_PATH     :EQUALS_PATH(?,path_string) :The EQUALS_PATH condition determines whether a resource in the Oracle XML database can be found in the database at a specified path.
EQUALS_PATH     :EQUALS_PATH(?,path_string,correlation_integer) :The EQUALS_PATH condition determines whether a resource in the Oracle XML database can be found in the database at a specified path.
UNDER_PATH      :UNDER_PATH(?,path_string) :The UNDER_PATH condition determines whether resources specified in a column can be found under a particular path specified by path_string in the Oracle XML database repository. The path information is computed by the RESOURCE_VIEW view, which you query to use this condition.
UNDER_PATH      :UNDER_PATH(?,levels,path_string) :The UNDER_PATH condition determines whether resources specified in a column can be found under a particular path specified by path_string in the Oracle XML database repository. The path information is computed by the RESOURCE_VIEW view, which you query to use this condition.
UNDER_PATH      :UNDER_PATH(?,path_string,correlation_integer) :The UNDER_PATH condition determines whether resources specified in a column can be found under a particular path specified by path_string in the Oracle XML database repository. The path information is computed by the RESOURCE_VIEW view, which you query to use this condition.
UNDER_PATH      :UNDER_PATH(?,levels,path_string,correlation_integer) :The UNDER_PATH condition determines whether resources specified in a column can be found under a particular path specified by path_string in the Oracle XML database repository. The path information is computed by the RESOURCE_VIEW view, which you query to use this condition.
[SQL For JSON Conditions]
IS JSON         :? IS JSON [FORMAT JSON] [STRICT|LAX] [ALLOW|DISALLOW SCALARS] [WITH|WITHOUT UNIQUE KEYS]:Use this SQL/JSON condition to test whether an expression is syntactically correct, or well-formed, JSON data.
IS NOT JSON     :? IS NOT JSON [FORMAT JSON] [STRICT|LAX] [ALLOW|DISALLOW SCALARS] [WITH|WITHOUT UNIQUE KEYS] :Use this SQL/JSON condition to test whether an expression is syntactically correct, or well-formed, JSON data.
JSON_EQUAL      :JSON_EQUAL(expr1, expr2)   :The Oracle SQL condition JSON_EQUAL compares two JSON values and returns true if they are equal. It returns false if the two values are not equal. The input values must be valid JSON data.
JSON_EXISTS     :JSON_EXISTS(expr[ FORMAT JSON],JSON_basic_path_expression [JSON_passing_clause] [JSON_exists_on_error_clause] [SON_exists_on_empty_clause])    :Use the SQL/JSON condition JSON_EXISTS to test whether a specified JSON value exists in JSON data. This condition returns TRUE if the JSON value exists and FALSE if the JSON value does not exist.
JSON_TEXTCONTAINS  :JSON_TEXTCONTAINS(?, JSON_basic_path_expression, string) :Use the SQL/JSON condition JSON_TEXTCONTAINS to test whether a specified character string exists in JSON property values. You can use this condition to filter JSON data on a specific word or number.
[BETWEEN Condition]
BETWEEN x AND y: BETWEEN x AND y:A BETWEEN condition determines whether the value of one expression is in an interval defined by two other expressions.
NOT BETWEEN x AND y:NOT BETWEEN x AND y:A BETWEEN condition determines whether the value of one expression is in an interval defined by two other expressions.
[EXISTS Condition]
EXISTS :EXISTS (subquery) :An EXISTS condition tests for existence of rows in a subquery.
[IN Condition]
IN              : expr IN(expression_list|subquery)       :An in_condition is a membership condition. It tests a value for membership in a list of values or subquery
NOT IN          : expr IN(expression_list|subquery)  :An in_condition is a membership condition. It tests a value for membership in a list of values or subquery
[IS OF type Condition]
IS OF type Condition    :expr IS OF TYPE (type)    :Use the IS OF type condition to test object instances based on their specific type information.
IS NOT OF type Condition    :expr IS NOT OF TYPE (type)    :Use the IS OF type condition to test object instances based on their specific type information.
{Single-Row Functions}
[Numeric Functions]
ABS                 :ABS(?)
ACOS                :ACOS(?)
ASIN                :ASIN(?)
ATAN                :ATAN(?)
ATAN2               :ATAN2(n1, n2)
BITAND              :BITAND(expr1, expr2)
CEIL                :CEIL(?)
COS                 :COS(?)
COSH                :COSH(?)
EXP                 :EXP(?)
FLOOR               :FLOOR(?)
LN                  :LN(?)
LOG                 :LOG(n2, n1)
MOD                 :MOD(n2, n1)
NANVL               :NANVL(n2, n1)
POWER               :POWER(n2, n1)
REMAINDER           :REMAINDER(n2, n1)
ROUND (number)      :ROUND(n, integer)
SIGN                :SIGN(?)
SIN                 :SIN(?)
SINH                :SINH(?)
SQRT                :SQRT(?)
TAN                 :TAN(?)
TANH                :TANH(?)
TRUNC               :TRUNC(n1[, n2])
WIDTH_BUCKET        :WIDTH_BUCKET(expr ,min_value ,max_value ,num_buckets ) :WIDTH_BUCKET lets you construct equiwidth histograms, in which the histogram range is divided into intervals that have identical size. (Compare this function with NTILE, which creates equiheight histograms.) Ideally each bucket is a closed-open interval of the real number line.
[Character Functions Returning Character Values]
CHR                     :CHR(? USING NCHAR_CS)                  :CHR
CONCAT                  :CONCAT(char1 ,char2)               :CONCAT
INITCAP                 :INITCAP(?)              :INITCAP
LOWER                   :LOWER(?)                :LOWER
LPAD                    :LPAD(expr1,n[,expr2])                 :LPAD
LTRIM                   :LTRIM(char[,set])                :LTRIM
NCHR                    :NCHR(?)                 :NCHR
NLS_INITCAP             :NLS_INITCAP(char[,'nlsparam'])          :NLS_INITCAP
NLS_LOWER               :NLS_LOWER(char[,'nlsparam'])            :NLS_LOWER
NLS_UPPER               :NLS_UPPER(char[,'nlsparam'])            :NLS_UPPER
NLSSORT                 :NLSSORT(char[,'nlsparam'])              :NLSSORT
REGEXP_REPLACE          :REGEXP_REPLACE(source_char,pattern[,replace_string[,position[,occurrence[,match_param]]]])       :REGEXP_REPLACE
REGEXP_SUBSTR           :REGEXP_SUBSTR(source_char,pattern[,replace_string[,position[,occurrence[,match_param [subexpr]]]]])        :REGEXP_SUBSTR
REPLACE                 :REPLACE(char,search_string [,replacement_string])              :REPLACE
RPAD                    :RPAD(expr1,n[,expr2])                 :RPAD
RTRIM                   :RTRIM(char[,set])                :RTRIM
SOUNDEX                 :SOUNDEX(char)              :SOUNDEX
SUBSTR                  :SUBSTR(char, position[,substring_length])               :SUBSTR
SUBSTRB                 :SUBSTRB(char, position[,substring_length])               :SUBSTR
SUBSTRC                 :SUBSTRC(char, position[,substring_length])               :SUBSTR
SUBSTR2                 :SUBSTR2(char, position[,substring_length])               :SUBSTR
SUBSTR4                 :SUBSTR4(char, position[,substring_length])               :SUBSTR
TRANSLATE               :TRANSLATE(expr, from_string ,to_string)            :TRANSLATE
TRANSLATE ... USING     :TRANSLATE(char USING CHAR_CS|NCHAR_CS):TRANSLATE ... USING
TRIM                    :TRIM(?)                 :TRIM
TRIM                    :TRIM(LEADING [trim_character] FROM trim_source)            :TRIM()
TRIM                    :TRIM(TRAILING [trim_character] FROM trim_source)          :TRIM(LEADING)
TRIM                    :TRIM(BOTH [trim_character] FROM trim_source)                 :TRIM(TRAILING)
TRIM                    :TRIM(trim_character FROM trim_source)               :TRIM(BOTH )
UPPER                   :UPPER(?)                :UPPER
[Character Functions Returning Number Values]
ASCII                 :ASCII(?)           :ASCII
INSTR                 :INSTR(string ,substring[,position [,occurrence]] )           :INSTR
LENGTH                :LENGTH(?)          :LENGTH
REGEXP_COUNT          :REGEXP_COUNT(source_char,pattern[,position[,match_param]])    :REGEXP_COUNT
REGEXP_INSTR          :REGEXP_INSTR(source_char,pattern[,position[,occurrence[,return_opt[,match_param[,subexpr]]]]])    :REGEXP_INSTR
[Character Set Functions]
NLS_CHARSET_DECL_LEN  :NLS_CHARSET_DECL_LEN(byte_count ,char_set_id )   :NLS_CHARSET_DECL_LEN returns the declaration length (in number of characters) of an NCHAR column. The byte_count argument is the width of the column. The char_set_id argument is the character set ID of the column.
NLS_CHARSET_ID        :NLS_CHARSET_ID(?)          :NLS_CHARSET_ID returns the character set ID number corresponding to character set name string. The string argument is a run-time VARCHAR2 value. The string value 'CHAR_CS' returns the database character set ID number of the server. The string value 'NCHAR_CS' returns the national character set ID number of the server.
NLS_CHARSET_NAME      :NLS_CHARSET_NAME(?)        :NLS_CHARSET_NAME returns the name of the character set corresponding to ID number number. The character set name is returned as a VARCHAR2 value in the database character set. If number is not recognized as a valid character set ID, then this function returns null.
[Collation Functions]
COLLATION             :COLLATION  (?)                 :COLLATION returns the name of the derived collation for expr. This function returns named collations and pseudo-collations. If the derived collation is a Unicode Collation Algorithm (UCA) collation, then the function returns the long form of its name. This function is evaluated during compilation of the SQL statement that contains it. If the derived collation is undefined due to a collation conflict while evaluating expr, then the function returns null.
NLS_COLLATION_ID      :NLS_COLLATION_ID(?)            :NLS_COLLATION_ID takes as its argument a collation name and returns the corresponding collation ID number. Collation IDs are used in the data dictionary tables and in Oracle Call Interface (OCI). Collation names are used in SQL statements and data dictionary views
NLS_COLLATION_NAME    :NLS_COLLATION_NAME(?[,flag])   :NLS_COLLATION_NAME takes as its argument a collation ID number and returns the corresponding collation name. Collation IDs are used in the data dictionary tables and in Oracle Call Interface (OCI). Collation names are used in SQL statements and data dictionary views
[Datetime Functions]
ADD_MONTHS              :ADD_MONTHS(day,integer)        :ADD_MONTHS returns the date date plus integer months. A month is defined by the session parameter NLS_CALENDAR. The date argument can be a datetime value or any value that can be implicitly converted to DATE. The integer argument can be an integer or any value that can be implicitly converted to an integer. The return type is always DATE, regardless of the data type of date. If date is the last day of the month or if the resulting month has fewer days than the day component of date, then the result is the last day of the resulting month. Otherwise, the result has the same day component as date.
CURRENT_DATE            :CURRENT_DATE       :CURRENT_DATE returns the current date in the session time zone, in a value in the Gregorian calendar of data type DATE.
CURRENT_TIMESTAMP       :CURRENT_TIMESTAMP  :CURRENT_TIMESTAMP returns the current date and time in the session time zone, in a value of data type TIMESTAMP WITH TIME ZONE. The time zone offset reflects the current local time of the SQL session. If you omit precision, then the default is 6. The difference between this function and LOCALTIMESTAMP is that CURRENT_TIMESTAMP returns a TIMESTAMP WITH TIME ZONE value while LOCALTIMESTAMP returns a TIMESTAMP value.
CURRENT_TIMESTAMP       :CURRENT_TIMESTAMP(precision)  :CURRENT_TIMESTAMP returns the current date and time in the session time zone, in a value of data type TIMESTAMP WITH TIME ZONE. The time zone offset reflects the current local time of the SQL session. If you omit precision, then the default is 6. The difference between this function and LOCALTIMESTAMP is that CURRENT_TIMESTAMP returns a TIMESTAMP WITH TIME ZONE value while LOCALTIMESTAMP returns a TIMESTAMP value.
DBTIMEZONE              :DBTIMEZONE :DBTIMEZONE returns the value of the database time zone. The return type is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the user specified the database time zone value in the most recent CREATE DATABASE or ALTER DATABASE statement.
EXTRACT                 :EXTRACT (YEAR|MONTH|DAY|HOUR|MINUTE|SECOND|TIMEZONE_HOUR|TIMEZONE_MINUTE|TIMEZONE_ABBR|TIMEZONE_REGION  FROM ?) :EXTRACT extracts and returns the value of a specified datetime field from a datetime or interval expression.
FROM_TZ                 :FROM_TZ(timestamp_value, time_zone_value )    :FROM_TZ converts a timestamp value and a time zone to a TIMESTAMP WITH TIME ZONE value.
LAST_DAY                :LAST_DAY(?)    :LAST_DAY returns the date of the last day of the month that contains date.
LOCALTIMESTAMP          :LOCALTIMESTAMP :LOCALTIMESTAMP returns the current date and time in the session time zone in a value of data type TIMESTAMP.
LOCALTIMESTAMP          :LOCALTIMESTAMP(timestamp_precision) :LOCALTIMESTAMP returns the current date and time in the session time zone in a value of data type TIMESTAMP.
MONTHS_BETWEEN          :MONTHS_BETWEEN(date1, date2) :MONTHS_BETWEEN returns number of months between dates date1 and date2.
NEW_TIME                :NEW_TIME(date,timezone1,timezone2 )   :NEW_TIME returns the date and time in time zone timezone2 when date and time in time zone timezone1 are date. Before using this function, you must set the NLS_DATE_FORMAT parameter to display 24-hour time. The return type is always DATE, regardless of the data type of date.
NEXT_DAY                :NEXT_DAY(date,char)   :NEXT_DAY returns the date of the first weekday named by char that is later than the date date. The return type is always DATE, regardless of the data type of date.
NUMTODSINTERVAL         :NUMTODSINTERVAL(n,'DAY'|'HOUR'|'MINUTE'|'SECOND')    :NUMTODSINTERVAL converts n to an INTERVAL DAY TO SECOND literal. The argument n can be any NUMBER value or an expression that can be implicitly converted to a NUMBER value. The argument interval_unit can be of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type.
NUMTOYMINTERVAL         :NUMTOYMINTERVAL(n,'YEAR'|'MONTH')    :NUMTOYMINTERVAL converts number n to an INTERVAL YEAR TO MONTH literal.
ORA_DST_AFFECTED        :ORA_DST_AFFECTED(datetime_expr)   :ORA_DST_AFFECTED is useful when you are changing the time zone data file for your database.
ORA_DST_CONVERT         :ORA_DST_CONVERT(datetime_expr[,integer[,integer]])    :ORA_DST_CONVERT is useful when you are changing the time zone data file for your database. The function lets you specify error handling for a specified datetime expression.
ORA_DST_ERROR           :ORA_DST_ERROR(datetime_expr)  :ORA_DST_ERROR is useful when you are changing the time zone data file for your database.
ROUND                   :ROUND (date[,fmt])   :ROUND returns date rounded to the unit specified by the format model fmt.
SESSIONTIMEZONE         :SESSIONTIMEZONE    :SESSIONTIMEZONE returns the time zone of the current session.
SYS_EXTRACT_UTC         :SYS_EXTRACT_UTC(datetime_value_with_time_zone)    :SYS_EXTRACT_UTC extracts the UTC (Coordinated Universal Timeâ€”formerly Greenwich Mean Time) from a datetime value with time zone offset or time zone region name.
SYSDATE                 :SYSDATE    :SYSDATE returns the current date and time set for the operating system on which the database server resides.
SYSTIMESTAMP            :SYSTIMESTAMP   :SYSTIMESTAMP returns the system date, including fractional seconds and time zone, of the system on which the database resides. The return type is TIMESTAMP WITH TIME ZONE.
TO_CHAR                 :TO_CHAR (?[,fmt[,'nlsparam']]) :TO_CHAR (datetime) converts a datetime or interval value of DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL DAY TO SECOND, or INTERVAL YEAR TO MONTH data type to a value of VARCHAR2 data type in the format specified by the date format fmt.
TO_DSINTERVAL           :TO_DSINTERVAL('sql_format'|'ds_iso_format')  :TO_DSINTERVAL converts its argument to a value of INTERVAL DAY TO SECOND data type.
TO_DSINTERVAL           :TO_DSINTERVAL('sql_format'|'ds_iso_format',DEFAULT return_value ON CONVERSION ERROR)  :TO_DSINTERVAL converts its argument to a value of INTERVAL DAY TO SECOND data type.
TO_TIMESTAMP            :TO_TIMESTAMP(?[,fmt[,'nlsparam']])   :TO_TIMESTAMP converts char to a value of TIMESTAMP data type.
TO_TIMESTAMP            :TO_TIMESTAMP(? DEFAULT return_value ON CONVERSION ERROR[,fmt[,'nlsparam']] )   :TO_TIMESTAMP converts char to a value of TIMESTAMP data type.
TO_TIMESTAMP_TZ         :TO_TIMESTAMP_TZ(?[,fmt[,'nlsparam']])    :TO_TIMESTAMP_TZ converts char to a value of TIMESTAMP WITH TIME ZONE data type.
TO_TIMESTAMP_TZ         :TO_TIMESTAMP_TZ(? DEFAULT return_value ON CONVERSION ERROR[,fmt[,'nlsparam']])    :TO_TIMESTAMP_TZ converts char to a value of TIMESTAMP WITH TIME ZONE data type.
TO_YMINTERVAL           :TO_YMINTERVAL  :TO_YMINTERVAL converts its argument to a value of INTERVAL MONTH TO YEAR data type.
TRUNC                   :TRUNC (date[,fmt])   :The TRUNC (date) function returns date with the time portion of the day truncated to the unit specified by the format model fmt.
TZ_OFFSET               :TZ_OFFSET('time_zone_name'|'[+|-]hh:mi'|SESSIONTIMEZONE|DBTIMEZONE)  :TZ_OFFSET returns the time zone offset corresponding to the argument based on the date the statement is executed.
[General Comparison Functions]
GREATEST              :GREATEST(expr,...)     :GREATEST returns the greatest of a list of one or more expressions.
LEAST                 :LEAST(expr,...)        :LEAST returns the least of a list of one or more expressions.
[Conversion Functions]
ASCIISTR                :ASCIISTR(?)   :ASCIISTR takes as its argument a string, or an expression that resolves to a string, in any character set and returns an ASCII version of the string in the database character set.
BIN_TO_NUM              :BIN_TO_NUM(expr,...) :BIN_TO_NUM converts a bit vector to its equivalent number. Each argument to this function represents a bit in the bit vector.
CAST                    :CAST(expr|MULTISET(subquery) AS type_name)   :CAST lets you convert built-in data types or collection-typed values of one type into another built-in data type or collection type.You can cast an unnamed operand (such as a date or the result set of a subquery) or a named collection (such as a varray or a nested table) into a type-compatible data type or named collection. The type_name must be the name of a built-in data type or collection type and the operand must be a built-in data type or must evaluate to a collection value.
CAST                    :CAST(expr|MULTISET(subquery) AS type_name DEFAULT return_value ON CONVERSION ERROR[,fmt[,'nlsparam']])   :CAST lets you convert built-in data types or collection-typed values of one type into another built-in data type or collection type.You can cast an unnamed operand (such as a date or the result set of a subquery) or a named collection (such as a varray or a nested table) into a type-compatible data type or named collection. The type_name must be the name of a built-in data type or collection type and the operand must be a built-in data type or must evaluate to a collection value.
CHARTOROWID             :CHARTOROWID(?)    :CHARTOROWID converts a value from CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to ROWID data type.
COMPOSE                 :COMPOSE(?)    :COMPOSE takes as its argument a character value char and returns the result of applying the Unicode canonical composition, as described in the Unicode Standard definition D117, to it.
CONVERT                 :CONVERT(?,dest_char_set ,source_char_set)    :CONVERT converts a character string from one character set to another.
DECOMPOSE               :DECOMPOSE(string[,CANONICAL|COMPATIBILITY])  :DECOMPOSE takes as its first argument a character value string and returns the result of applying one of the Unicode decompositions to it.
HEXTORAW                :HEXTORAW(?)   :HEXTORAW converts char containing hexadecimal digits in the CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to a raw value.
NUMTODSINTERVAL         :NUMTODSINTERVAL(?,'DAY'|'HOUR'|'MINUTE'|'SECOND')    :NUMTODSINTERVAL converts n to an INTERVAL DAY TO SECOND literal. The argument n can be any NUMBER value or an expression that can be implicitly converted to a NUMBER value.
NUMTOYMINTERVAL         :NUMTOYMINTERVAL(?,'YEAR'|'MONTH')    :NUMTOYMINTERVAL converts number n to an INTERVAL YEAR TO MONTH literal.
RAWTOHEX                :RAWTOHEX(?)   :RAWTOHEX converts raw to a character value containing its hexadecimal representation.
RAWTONHEX               :RAWTONHEX(?)  :RAWTONHEX converts raw to a character value containing its hexadecimal representation.
ROWIDTOCHAR             :ROWIDTOCHAR(?)    :ROWIDTOCHAR converts a rowid value to VARCHAR2 data type. The result of this conversion is always 18 characters long.
ROWIDTONCHAR            :ROWIDTONCHAR(?)   :ROWIDTONCHAR converts a rowid value to NVARCHAR2 data type. The result of this conversion is always in the national character set and is 18 characters long.
SCN_TO_TIMESTAMP        :SCN_TO_TIMESTAMP(?)   :SCN_TO_TIMESTAMP takes as an argument a number that evaluates to a system change number (SCN), and returns the approximate timestamp associated with that SCN. The returned value is of TIMESTAMP data type.
TIMESTAMP_TO_SCN        :TIMESTAMP_TO_SCN(?)   :TIMESTAMP_TO_SCN takes as an argument a timestamp value and returns the approximate system change number (SCN) associated with that timestamp. The returned value is of data type NUMBER. This function is useful any time you want to know the SCN associated with a particular timestamp.
TO_BINARY_DOUBLE        :TO_BINARY_DOUBLE(?)   :TO_BINARY_DOUBLE converts expr to a double-precision floating-point number.
TO_BINARY_DOUBLE        :TO_BINARY_DOUBLE(? DEFAULT return_value ON CONVERSION ERROR[,fmt[,'nlsparam']])   :TO_BINARY_DOUBLE converts expr to a double-precision floating-point number.
TO_BINARY_FLOAT         :TO_BINARY_FLOAT(?)    :TO_BINARY_FLOAT converts expr to a single-precision floating-point number.
TO_BINARY_FLOAT         :TO_BINARY_FLOAT(? DEFAULT return_value ON CONVERSION ERROR[,fmt[,'nlsparam']])   :TO_BINARY_FLOAT converts expr to a double-precision floating-point number.
TO_BLOB                 :TO_BLOB (?[,mime_type])    :TO_BLOB (bfile) converts a BFILE value to a BLOB value.
TO_BLOB                 :TO_BLOB (?)  :TO_BLOB (raw) converts LONG RAW and RAW values to BLOB values.
TO_CHAR                 :TO_CHAR (?[,csid])   :TO_CHAR (bfile|blob) converts BFILE or BLOB data to the database character set.
TO_CHAR                 :TO_CHAR (?)    :TO_CHAR (character) converts NCHAR, NVARCHAR2, CLOB, or NCLOB data to the database character set. The value returned is always VARCHAR2.
TO_CHAR                 :TO_CHAR (? [,fmt[,'nlsparam']) :TO_CHAR (datetime) converts a datetime or interval value of DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL DAY TO SECOND, or INTERVAL YEAR TO MONTH data type to a value of VARCHAR2 data type in the format specified by the date format fmt.
TO_CHAR                 :TO_CHAR (?[,fmt[,'nlsparam'])   :TO_CHAR (number) converts n to a value of VARCHAR2 data type, using the optional number format fmt. The value n can be of type NUMBER, BINARY_FLOAT, or BINARY_DOUBLE. If you omit fmt, then n is converted to a VARCHAR2 value exactly long enough to hold its significant digits.
TO_CLOB                 :TO_CLOB (?[,csid][,'mime_type'])   :TO_CLOB (bfile|blob) converts BFILE or BLOB data to the database character set and returns the data as a CLOB value.
TO_CLOB                 :TO_CLOB (?)    :TO_CLOB (character) converts NCLOB values in a LOB column or other character strings to CLOB values.
TO_DATE                 :TO_DATE(? [DEFAULT return_value ON CONVERSION ERROR][,fmt[,'nlsparam']])    :TO_DATE converts char to a value of DATE data type.
TO_DSINTERVAL           :TO_DSINTERVAL('sql_format|ds_iso_format' [DEFAULT return_value ON CONVERSION ERROR])  :TO_DSINTERVAL converts its argument to a value of INTERVAL DAY TO SECOND data type.
TO_LOB                  :TO_LOB(?) :TO_LOB converts LONG or LONG RAW values in the column long_column to LOB values.
TO_MULTI_BYTE           :TO_MULTI_BYTE(?)  :TO_MULTI_BYTE returns char with all of its single-byte characters converted to their corresponding multibyte characters.
TO_NCHAR                :TO_NCHAR (?)   :TO_NCHAR (character) converts a character string, CHAR, VARCHAR2, CLOB, or NCLOB value to the national character set.
TO_NCHAR                :TO_NCHAR (? [,fmt[,'nlsparam']])    :TO_NCHAR (datetime) converts a datetime or interval value of DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL MONTH TO YEAR, or INTERVAL DAY TO SECOND data type from the database character set to the national character set.
TO_NCHAR                :TO_NCHAR (? [,fmt[,'nlsparam']])  :TO_NCHAR (number) converts n to a string in the national character set.
TO_NCLOB                :TO_NCLOB(?)   :TO_NCLOB converts CLOB values in a LOB column or other character strings to NCLOB values.
TO_NUMBER               :TO_NUMBER(? DEFAULT return_value ON CONVERSION ERROR[,fmt[,'nlsparam']])  :TO_NUMBER converts expr to a value of NUMBER data type.
TO_SINGLE_BYTE          :TO_SINGLE_BYTE(?) :TO_SINGLE_BYTE returns char with all of its multibyte characters converted to their corresponding single-byte characters.
TO_TIMESTAMP            :TO_TIMESTAMP(? DEFAULT return_value ON CONVERSION ERROR[,fmt[,'nlsparam']])   :TO_TIMESTAMP converts char to a value of TIMESTAMP data type.
TO_TIMESTAMP_TZ         :TO_TIMESTAMP_TZ(? DEFAULT return_value ON CONVERSION ERROR[,fmt[,'nlsparam']])    :TO_TIMESTAMP_TZ converts char to a value of TIMESTAMP WITH TIME ZONE data type.
TO_YMINTERVAL           :TO_YMINTERVAL('[+|-] years-months|ym_iso_format' [DEFAULT return_value ON CONVERSION ERROR])  :TO_YMINTERVAL converts its argument to a value of INTERVAL MONTH TO YEAR data type.
TREAT                   :TREAT(? AS [REF][ schema.]type|JSON)  :You can use the TREAT function to change the declared type of an expression.
UNISTR                  :UNISTR(?) :UNISTR takes as its argument a text literal or an expression that resolves to character data and returns it in the national character set.
VALIDATE_CONVERSION     :VALIDATE_CONVERSION(? AS type_name[,fmt[,'nlsparam']])    :VALIDATE_CONVERSION determines whether expr can be converted to the specified data type. If expr can be successfully converted, then this function returns 1; otherwise, this function returns 0. If expr evaluates to null, then this function returns 1. If an error occurs while evaluating expr, then this function returns the error.
[Large Object Functions]
BFILENAME     :BFILENAME('directory','filename')    :BFILENAME returns a BFILE locator that is associated with a physical LOB binary file on the server file system.
EMPTY_BLOB    :EMPTY_BLOB()   :EMPTY_BLOB and EMPTY_CLOB return an empty LOB locator that can be used to initialize a LOB variable or, in an INSERT or UPDATE statement, to initialize a LOB column or attribute to EMPTY.
EMPTY_CLOB    :EMPTY_CLOB()   :EMPTY_BLOB and EMPTY_CLOB return an empty LOB locator that can be used to initialize a LOB variable or, in an INSERT or UPDATE statement, to initialize a LOB column or attribute to EMPTY.
[Collection Functions]
CARDINALITY                   :CARDINALITY(nested_table)                      :CARDINALITY returns the number of elements in a nested table. The return type is NUMBER. If the nested table is empty, or is a null collection, then CARDINALITY returns NULL.
COLLECT                       :COLLECT([DISTINCT|UNIQUE] ? ORDER BY expr)     :COLLECT is an aggregate function that takes as its argument a column of any type and creates a nested table of the input type out of the rows selected. To get accurate results from this function you must use it within a CAST function.
POWERMULTISET                 :POWERMULTISET(?)                               :POWERMULTISET takes as input a nested table and returns a nested table of nested tables containing all nonempty subsets (called submultisets) of the input nested table.
POWERMULTISET_BY_CARDINALITY  :POWERMULTISET_BY_CARDINALITY(?, cardinality)   :POWERMULTISET_BY_CARDINALITY takes as input a nested table and a cardinality and returns a nested table of nested tables containing all nonempty subsets (called submultisets) of the nested table of the specified cardinality.
SET                           :SET(nested_table)                              :SET converts a nested table into a set by eliminating duplicates. The function returns a nested table whose elements are distinct from one another. The returned nested table is of the same type as the input nested table.
[Hierarchical Functions]
SYS_CONNECT_BY_PATH           :SYS_CONNECT_BY_PATH(?,char)                    :SYS_CONNECT_BY_PATH is valid only in hierarchical queries. It returns the path of a column value from root to node, with column values separated by char for each row returned by CONNECT BY condition.
[XML Functions]
DEPTH           :DEPTH(?)                 : DEPTH is an ancillary function used only with the UNDER_PATH and EQUALS_PATH conditions. It returns the number of levels in the path specified by the UNDER_PATH condition with the same correlation variable.
EXISTSNODE      :EXISTSNODE(XMLType_instance,Xpath_string[,namespace_string])             :EXISTSNODE determines whether traversal of an XML document using a specified path results in any nodes.
EXTRACT         :EXTRACT(XMLType_instance,Xpath_string[,namespace_string])          :EXTRACT (XML) is similar to the EXISTSNODE function. It applies a VARCHAR2 XPath string and returns an XMLType instance containing an XML fragment. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. The optional namespace_string is required if the XML you are handling uses a namespace prefix. This argument must resolve to a VARCHAR2 value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s).
EXTRACTVALUE    :EXTRACTVALUE(XMLType_instance,Xpath_string[,namespace_string])           :The EXTRACTVALUE function takes as arguments an XMLType instance and an XPath expression and returns a scalar value of the resultant node.
PATH            :PATH(?)                   :PATH is an ancillary function used only with the UNDER_PATH and EQUALS_PATH conditions. It returns the relative path that leads to the resource specified in the parent condition.
SYS_DBURIGEN    :SYS_DBURIGEN({column|attribute [rowid]},...[,'text()'])           :SYS_DBURIGen takes as its argument one or more columns or attributes, and optionally a rowid, and generates a URL of data type DBURIType to a particular column or row object.
SYS_XMLAGG      :SYS_XMLAGG(expr[,fmt])             :SYS_XMLAgg aggregates all of the XML documents or fragments represented by expr and produces a single XML document. It adds a new enclosing element with a default name ROWSET. If you want to format the XML document differently, then specify fmt, which is an instance of the XMLFormat object.
SYS_XMLGEN      :SYS_XMLGEN(expr[,fmt])             :SYS_XMLGen takes an expression that evaluates to a particular row and column of the database, and returns an instance of type XMLType containing an XML document.
XMLAGG          :XMLAGG(XMLType_instance [order_by_clause])                 :XMLAgg is an aggregate function. It takes a collection of XML fragments and returns an aggregated XML document. Any arguments that return null are dropped from the result.
XMLCAST         :XMLCAST(value_expression AS datatype)                :XMLCast casts value_expression to the scalar SQL data type specified by datatype. The value_expression argument is a SQL expression that is evaluated. The datatype argument can be of data type NUMBER, VARCHAR2, CHAR, CLOB, BLOB, REF XMLTYPE, and any of the datetime data types.
XMLCDATA        :XMLCDATA(?)               :XMLCData generates a CDATA section by evaluating value_expr.
XMLCOLATTVAL    :XMLCOLATTVAL(value_expr [AS c_alias|EVALNAME value_expr],...)           :XMLColAttVal creates an XML fragment and then expands the resulting XML so that each XML fragment has the name column with the attribute name.
XMLCOMMENT      :XMLCOMMENT(?)             :XMLComment generates an XML comment using an evaluated result of value_expr.
XMLCONCAT       :XMLCONCAT(XMLType_instance,...)              :XMLConcat takes as input a series of XMLType instances, concatenates the series of elements for each row, and returns the concatenated series. XMLConcat is the inverse of XMLSequence.
XMLDIFF         :XMLDIFF(XMLType_instance,XMLType_document[,integer,string])                :The XMLDiff function is the SQL interface for the XmlDiff C API. This function compares two XML documents and captures the differences in XML conforming to an Xdiff schema. The diff document is returned as an XMLType document.
XMLELEMENT      :XMLELEMENT([ENTITYESCAPING|NONENTITYESCAPING] {[NAME] identifier|EVALNAME value_expr}[,XML_attributes_clause][,value_expr [AS c_alias]...]  )             :XMLElement takes an element name for identifier or evaluates an element name for EVALNAME value_expr, an optional collection of attributes for the element, and arguments that make up the content of the element. It returns an instance of type XMLType. XMLElement is similar to SYS_XMLGen except that XMLElement can include attributes in the XML returned, but it does not accept formatting using the XMLFormat object.
XMLEXISTS       :XMLEXISTS(XQuery_string [XML_passing_clause])              :XMLExists checks whether a given XQuery expression returns a nonempty XQuery sequence. If so, the function returns TRUE; otherwise, it returns FALSE. The argument XQuery_string is a literal string, but it can contain XQuery variables that you bind using the XML_passing_clause.
XMLFOREST       :XMLFOREST(value_expr [AS c_alias|EVALNAME value_expr],...)              :XMLForest converts each of its argument parameters to XML, and then returns an XML fragment that is the concatenation of these converted arguments.
XMLISVALID      :XMLISVALID(XMLType_instance,XMLSchema_URL[,element])             :XMLISVALID checks whether the input XMLType_instance conforms to the relevant XML schema. It does not change the validation status recorded for XMLType_instance.
XMLPARSE        :XMLPARSE(DOCUMENT|CONTENT value_expr[ WELLFORMED])               :XMLParse parses and generates an XML instance from the evaluated result of value_expr. The value_expr must resolve to a string. If value_expr resolves to null, then the function returns null.
XMLPATCH        :XMLPATCH(XMLType_instance,XMLType_document)               :The XMLPatch function is the SQL interface for the XmlPatch C API. This function patches an XML document with the changes specified. A patched XMLType document is returned.
XMLPI           :XMLPI({[NAME] identifier|EVALNAME value_expr}[,value_expr])                  :XMLPI generates an XML processing instruction using identifier and optionally the evaluated result of value_expr. A processing instruction is commonly used to provide to an application information that is associated with all or part of an XML document. The application uses the processing instruction to determine how best to process the XML document.
XMLQUERY        :XMLQUERY([XML_passing_clause ]RETURNING CONTENT[ NULL ON EMPTY])               :XMLQUERY lets you query XML data in SQL statements. It takes an XQuery expression as a string literal, an optional context item, and other bind variables and returns the result of evaluating the XQuery expression using these input values.
XMLSERIALIZE    :XMLSERIALIZE(DOCUMENT|CONTENT value_expr[ AS datatype])           :XMLSerialize creates a string or LOB containing the contents of value_expr.
XMLTABLE        :XMLTABLE([XMLnamespaces_clause,]XQuery_string XMLTABLE_options)               :XMLTable maps the result of an XQuery evaluation into relational rows and columns. You can query the result returned by the function as a virtual relational table using SQL.
XMLTRANSFORM    :XMLTRANSFORM(XMLType_instance,XMLType_instance|string)           :XMLTransform takes as arguments an XMLType instance and an XSL style sheet, which is itself a form of XMLType instance. It applies the style sheet to the instance and returns an XMLType.
[JSON Functions]
JSON_QUERY              :JSON_QUERY(expr[ FORMAT JSON],JSON_basic_path_expression[ JSON_query_returning_clause][ JSON_query_wrapper_clause][ JSON_query_on_error_clause][ JSON_query_on_empty_clause][ JSON_query_on_mismatch_clause])       :JSON_QUERY selects and returns one or more values from JSON data and returns those values. You can use JSON_QUERY to retrieve fragments of a JSON document.
JSON_TABLE              :JSON_TABLE(expr[ FORMAT JSON][,JSON_basic_path_expression][ JSON_table_on_error_clause] JSON_columns_clause)       :The SQL/JSON function JSON_TABLE creates a relational view of JSON data. It maps the result of a JSON data evaluation into relational rows and columns. You can query the result returned by the function as a virtual relational table using SQL. The main purpose of JSON_TABLE is to create a row of relational data for each object inside a JSON array and output JSON values from within that object as individual SQL column values.
JSON_VALUE              :JSON_VALUE(expr[ FORMAT JSON][,JSON_basic_path_expression][ JSON_value_returning_clause][ JSON_value_on_error_clause][ JSON_value_on_empty_clause][ JSON_value_on_mismatch_clause])       :The SQL/JSON function JSON_VALUE finds a specified scalar JSON value in JSON data and returns it as a SQL value.
JSON_ARRAY              :JSON_ARRAY(JSON_ARRAY(JSON_ARRAY_content)|JSON[JSON_ARRAY_content])               :The SQL/JSON function JSON_ARRAY takes as its input a sequence of SQL scalar expressions or one collection type instance, VARRAY or NESTED TABLE.
JSON_ARRAYAGG           :JSON_ARRAYAGG(expr[ FORMAT JSON][ order_by_clause][ JSON_on_null_clause][ JSON_returning_clause][ STRICT])            :The SQL/JSON function JSON_ARRAYAGG is an aggregate function. It takes as its input a column of SQL expressions, converts each expression to a JSON value, and returns a single JSON array that contains those JSON values.
JSON_OBJECT             :JSON_OBJECT(JSON_OBJECT(JSON_OBJECT_content)|JSON{JSON_OBJECT_content})              :The SQL/JSON function JSON_OBJECT takes as its input either a sequence of key-value pairs or one object type instance. A collection type cannot be passed to JSON_OBJECT.
JSON_OBJECTAGG          :JSON_OBJECTAGG([KEY ]key_expr VALUE value_expr[ JSON_on_null_clause][ JSON_returning_clause][ STRICT][ WITH UNIQUE KEYS])           :The SQL/JSON function JSON_OBJECTAGG is an aggregate function. It takes as its input a property key-value pair. Typically, the property key, the property value, or both are columns of SQL expressions. This function constructs an object member for each key-value pair and returns a single JSON object that contains those object members.
JSON Type Constructor   :JSON(?)    :You can use the JSON data type constructor JSON to parse textual JSON input ( a scalar, object, or array), and return it as an instance of type JSON.
JSON_SCALAR             :JSON_SCALAR(expr[ SQL|JSON][ NULL ON NULL])              :JSON_SCALAR accepts a SQL scalar value as input and returns a corresponding JSON scalar value as a JSON type instance. In particular, the value can be of an Oracle-specific JSON-language type, such as a date, which is not part of the JSON standard.
JSON_SERIALIZE          :JSON_SERIALIZE(expr[ JSON_returning_clause][ PRETTY][ ASCII][ TRUNCATE][ {NULL|ERROR|EMPTY ARRAY|OBJECT} ON ERROR])           :json_serialize takes JSON data of any SQL data type (JSON, VARCHAR2, CLOB, or BLOB) as input and returns a textual representation of it. You typically use it to transform the result of a query.
JSON_TRANSFORM          :JSON_TRANSFORM(input_expr,operation...) JSON_TRANSFORM_returning_clause JSON_passing_clause          :You can use the JSON_TRANSFORM function to change input JSON data (or pieces of JSON data), by specifying one or more modifying operations that perform changes to the JSON data. You will get the modified JSON as output.
JSON_DATAGUIDE          :JSON_DATAGUIDE(expr[,format[,flag]])       :The aggregate function JSON_DATAGUIDE computes the data guide of a set of JSON data. The data guide is returned as a CLOB which can be in either flat or hierarchical format depending on the passing format parameter.
[Encoding and Decoding Functions]
DECODE          :DECODE(expr,{search,result}...[,default])          :DECODE compares expr to each search value one by one. If expr is equal to a search, then Oracle Database returns the corresponding result. If no match is found, then Oracle returns default. If default is omitted, then Oracle returns null.
DUMP            :DUMP(expr[,return_fmt [,start_position [,length]]])            :DUMP returns a VARCHAR2 value containing the data type code, length in bytes, and internal representation of expr. The returned result is always in the database character set.
ORA_HASH        :ORA_HASH(expr[,max_bucket[,seed_value]])        :ORA_HASH is a function that computes a hash value for a given expression. This function is useful for operations such as analyzing a subset of data and generating a random sample.
STANDARD_HASH   :STANDARD_HASH(expr[,'method'])   :STANDARD_HASH computes a hash value for a given expression using one of several hash algorithms that are defined and standardized by the National Institute of Standards and Technology. This function is useful for performing authentication and maintaining data integrity in security applications such as digital signatures, checksums, and fingerprinting.
VSIZE           :VSIZE(?)           :VSIZE returns the number of bytes in the internal representation of expr. If expr is null, then this function returns null.
[NULL-Related Functions]
COALESCE        :COALESCE(expr...)       :COALESCE returns the first non-null expr in the expression list. You must specify at least two expressions. If all occurrences of expr evaluate to null, then the function returns null.
LNNVL           :LNNVL(condition)          :LNNVL provides a concise way to evaluate a condition when one or both operands of the condition may be null. The function can be used in the WHERE clause of a query, or as the WHEN condition in a searched CASE expression. It takes as an argument a condition and returns TRUE if the condition is FALSE or UNKNOWN and FALSE if the condition is TRUE. LNNVL can be used anywhere a scalar expression can appear, even in contexts where the IS [NOT] NULL, AND, or OR conditions are not valid but would otherwise be required to account for potential nulls.
NANVL           :NANVL(n2,n1)          :The NANVL function is useful only for floating-point numbers of type BINARY_FLOAT or BINARY_DOUBLE. It instructs Oracle Database to return an alternative value n1 if the input value n2 is NaN (not a number). If n2 is not NaN, then Oracle returns n2.
NULLIF          :NULLIF(expr1,expr2)         :NULLIF compares expr1 and expr2. If they are equal, then the function returns null. If they are not equal, then the function returns expr1. You cannot specify the literal NULL for expr1.
NVL             :NVL(expr1,expr2)            :NVL lets you replace null (returned as a blank) with a string in the results of a query. If expr1 is null, then NVL returns expr2. If expr1 is not null, then NVL returns expr1.
NVL2            :NVL2(expr1,expr2,expr3)           :NVL2 lets you determine the value returned by a query based on whether a specified expression is null or not null. If expr1 is not null, then NVL2 returns expr2. If expr1 is null, then NVL2 returns expr3.
[AggregateFunctions]
ANY_VALUE                       :ANY_VALUE(?)                    :ANY_VALUE returns a single non-deterministic value of expr. You can use it as an aggregate function.
ANY_VALUE                       :ANY_VALUE(DISTINCT ?)           :ANY_VALUE returns a single non-deterministic value of expr. You can use it as an aggregate function.
ANY_VALUE                       :ANY_VALUE(ALL ?)                :ANY_VALUE returns a single non-deterministic value of expr. You can use it as an aggregate function.
APPROX_COUNT                    :APPROX_COUNT(?)                  :APPROX_COUNT returns the approximate count of an expression. If you supply MAX_ERROR as the second argument, then the function returns the maximum error between the actual and approximate count.
APPROX_COUNT(*)                 :APPROX_COUNT(*)                  :APPROX_COUNT returns the approximate count of an expression. If you supply MAX_ERROR as the second argument, then the function returns the maximum error between the actual and approximate count.
APPROX_COUNT_DISTINCT           :APPROX_COUNT_DISTINCT(?)         :APPROX_COUNT_DISTINCT returns the approximate number of rows that contain a distinct value for expr.
APPROX_COUNT_DISTINCT_AGG       :APPROX_COUNT_DISTINCT_AGG(?)     :APPROX_COUNT_DISTINCT_AGG takes as its input a column of details containing information about approximate distinct value counts, and enables you to perform aggregations of those counts.
APPROX_COUNT_DISTINCT_DETAIL    :APPROX_COUNT_DISTINCT_DETAIL(?)  :APPROX_COUNT_DISTINCT_DETAIL calculates information about the approximate number of rows that contain a distinct value for expr and returns a BLOB value, called a detail, which contains that information in a special format.
APPROX_MEDIAN                   :APPROX_MEDIAN(?)                 :APPROX_MEDIAN is an approximate inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns an approximate middle value or an approximate interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.
APPROX_MEDIAN                   :APPROX_MEDIAN(?,DETERMINISTIC)                 :APPROX_MEDIAN is an approximate inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns an approximate middle value or an approximate interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.
APPROX_MEDIAN                   :APPROX_MEDIAN(?,'ERROR_RATE' | 'CONFIDENCE')                 :APPROX_MEDIAN is an approximate inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns an approximate middle value or an approximate interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.
APPROX_MEDIAN                   :APPROX_MEDIAN(?,DETERMINISTIC,'ERROR_RATE' | 'CONFIDENCE')                 :APPROX_MEDIAN is an approximate inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns an approximate middle value or an approximate interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.
APPROX_PERCENTILE               :APPROX_PERCENTILE(?) WITHIN GROUP (ORDER BY ? ASC|DESC)             :APPROX_PERCENTILE is an approximate inverse distribution function. It takes a percentile value and a sort specification, and returns the value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation
APPROX_PERCENTILE               :APPROX_PERCENTILE(?,DETERMINISTIC) WITHIN GROUP (ORDER BY ? ASC|DESC)             :APPROX_PERCENTILE is an approximate inverse distribution function. It takes a percentile value and a sort specification, and returns the value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation
APPROX_PERCENTILE               :APPROX_PERCENTILE(?,'ERROR_RATE' | 'CONFIDENCE') WITHIN GROUP (ORDER BY ? ASC|DESC)             :APPROX_PERCENTILE is an approximate inverse distribution function. It takes a percentile value and a sort specification, and returns the value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation
APPROX_PERCENTILE               :APPROX_PERCENTILE(?,DETERMINISTIC,'ERROR_RATE' | 'CONFIDENCE) WITHIN GROUP (ORDER BY ? ASC|DESC)             :APPROX_PERCENTILE is an approximate inverse distribution function. It takes a percentile value and a sort specification, and returns the value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation
APPROX_PERCENTILE_AGG           :APPROX_PERCENTILE_AGG(?)         :APPROX_PERCENTILE_AGG takes as its input a column of details containing approximate percentile information, and enables you to perform aggregations of that information.
APPROX_PERCENTILE_DETAIL        :APPROX_PERCENTILE_DETAIL(?)      :APPROX_PERCENTILE_DETAIL calculates approximate percentile information for the values of expr and returns a BLOB value, called a detail, which contains that information in a special format.
APPROX_PERCENTILE_DETAIL        :APPROX_PERCENTILE_DETAIL(?,DETERMINISTIC)      :APPROX_PERCENTILE_DETAIL calculates approximate percentile information for the values of expr and returns a BLOB value, called a detail, which contains that information in a special format.
APPROX_RANK                     :APPROX_RANK(?)                   :APPROX_RANK returns the approximate value in a group of values.
APPROX_RANK                     :APPROX_RANK(? PARTITION BY PARTITION_BY_clause)                   :APPROX_RANK returns the approximate value in a group of values.
APPROX_RANK                     :APPROX_RANK(? PARTITION BY PARTITION_BY_clause ORDER BY ORDER_BY_clause DESC)                   :APPROX_RANK returns the approximate value in a group of values.
APPROX_SUM                      :APPROX_SUM(*)                    :APPROX_SUM returns the approximate sum of an expression. If you supply MAX_ERROR as the second argument, then the function returns the maximum error between the actual and approximate sum.
APPROX_SUM                      :APPROX_SUM(?)                    :APPROX_SUM returns the approximate sum of an expression. If you supply MAX_ERROR as the second argument, then the function returns the maximum error between the actual and approximate sum.
APPROX_SUM                      :APPROX_SUM(?,MAX_ERROR)                    :APPROX_SUM returns the approximate sum of an expression. If you supply MAX_ERROR as the second argument, then the function returns the maximum error between the actual and approximate sum.
AVG                             :AVG(?)                           :AVG returns average value of expr.This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.
AVG                             :AVG(DISTINCT ?)                           :AVG returns average value of expr.This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.
AVG                             :AVG(ALL ?)                           :AVG returns average value of expr.This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.
AVG                             :AVG(?) OVER analytic_clause                          :AVG returns average value of expr.This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.
BIT_AND_AGG                     :BIT_AND_AGG(?)                     :BIT_AND_AGG is a bitwise aggregation function that returns the result of a bitwise AND operation.
BIT_AND_AGG                     :BIT_AND_AGG(DISTINCT ?)            :BIT_AND_AGG is a bitwise aggregation function that returns the result of a bitwise AND operation.
BIT_AND_AGG                     :BIT_AND_AGG(UNIQUE ?)              :BIT_AND_AGG is a bitwise aggregation function that returns the result of a bitwise AND operation.
BIT_AND_AGG                     :BIT_AND_AGG(ALL ?)                 :BIT_AND_AGG is a bitwise aggregation function that returns the result of a bitwise AND operation.
BIT_OR_AGG                      :BIT_OR_AGG(?)                             :BIT_OR_AGG is a bitwise aggregation function that returns the result of a bitwise OR operation.
BIT_OR_AGG                      :BIT_OR_AGG(DISTINCT ?)                    :BIT_OR_AGG is a bitwise aggregation function that returns the result of a bitwise OR operation.
BIT_OR_AGG                      :BIT_OR_AGG(UNIQUE ?)                      :BIT_OR_AGG is a bitwise aggregation function that returns the result of a bitwise OR operation.
BIT_OR_AGG                      :BIT_OR_AGG(ALL ?)                         :BIT_OR_AGG is a bitwise aggregation function that returns the result of a bitwise OR operation.
BIT_XOR_AGG                     :BIT_XOR_AGG(?)                       :BIT_XOR_AGG is a bitwise aggregation function that returns the result of a bitwise XOR operation.
BIT_XOR_AGG                     :BIT_XOR_AGG(DISTINCT ?)              :BIT_XOR_AGG is a bitwise aggregation function that returns the result of a bitwise XOR operation.
BIT_XOR_AGG                     :BIT_XOR_AGG(UNIQUE ?)                :BIT_XOR_AGG is a bitwise aggregation function that returns the result of a bitwise XOR operation.
BIT_XOR_AGG                     :BIT_XOR_AGG(ALL ?)                   :BIT_XOR_AGG is a bitwise aggregation function that returns the result of a bitwise XOR operation.
CHECKSUM                        :CHECKSUM(?)                               :Use CHECKSUM to detect changes in a table. The order of the rows in the table does not affect the result. You can use CHECKSUM with DISTINCT, as part of a GROUP BY query, as a window function, or an analytical function.
CHECKSUM                        :CHECKSUM(DISTINCT ?)                      :Use CHECKSUM to detect changes in a table. The order of the rows in the table does not affect the result. You can use CHECKSUM with DISTINCT, as part of a GROUP BY query, as a window function, or an analytical function.
CHECKSUM                        :CHECKSUM(ALL ?)                           :Use CHECKSUM to detect changes in a table. The order of the rows in the table does not affect the result. You can use CHECKSUM with DISTINCT, as part of a GROUP BY query, as a window function, or an analytical function.
COLLECT                         :COLLECT(?)                       :COLLECT is an aggregate function that takes as its argument a column of any type and creates a nested table of the input type out of the rows selected. To get accurate results from this function you must use it within a CAST function.
COLLECT                         :COLLECT(DISTINCT ?)                       :COLLECT is an aggregate function that takes as its argument a column of any type and creates a nested table of the input type out of the rows selected. To get accurate results from this function you must use it within a CAST function.
COLLECT                         :COLLECT(UNIQUE ?)                         :COLLECT is an aggregate function that takes as its argument a column of any type and creates a nested table of the input type out of the rows selected. To get accurate results from this function you must use it within a CAST function.
COLLECT                         :COLLECT(? ORDER BY ?)                       :COLLECT is an aggregate function that takes as its argument a column of any type and creates a nested table of the input type out of the rows selected. To get accurate results from this function you must use it within a CAST function.
COLLECT                         :COLLECT(DISTINCT ? ORDER BY ?)                       :COLLECT is an aggregate function that takes as its argument a column of any type and creates a nested table of the input type out of the rows selected. To get accurate results from this function you must use it within a CAST function.
COLLECT                         :COLLECT(UNIQUE ? ORDER BY ?)                         :COLLECT is an aggregate function that takes as its argument a column of any type and creates a nested table of the input type out of the rows selected. To get accurate results from this function you must use it within a CAST function.
CORR                            :CORR(?,?)                          :Analytic Functions for information on syntax, semantics, and restrictions
CORR                            :CORR(?,?) OVER(analytic_clause)                          :Analytic Functions for information on syntax, semantics, and restrictions
CORR_K                          :CORR_K(?,?)                        :The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
CORR_K                          :CORR_K(?,?,COEFFICIENT)                        :The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
CORR_K                          :CORR_K(?,?,ONE_SIDED_SIG)                        :The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
CORR_K                          :CORR_K(?,?,ONE_SIDED_SIG_POS)                        :The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
CORR_K                          :CORR_K(?,?,ONE_SIDED_SIG_NEG)                        :The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
CORR_K                          :CORR_K(?,?,TWO_SIDED_SIG)                        :The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
CORR_S                          :CORR_S(?,?)                        :The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
CORR_S                          :CORR_S(?,?,COEFFICIENT)                        :The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
CORR_S                          :CORR_S(?,?,ONE_SIDED_SIG)                        :The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
CORR_S                          :CORR_S(?,?,ONE_SIDED_SIG_POS)                        :The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
CORR_S                          :CORR_S(?,?,ONE_SIDED_SIG_NEG)                        :The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
CORR_S                          :CORR_S(?,?,TWO_SIDED_SIG)                        :The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
COUNT                           :COUNT(*)                         :COUNT returns the number of rows returned by the query. You can use it as an aggregate or analytic function.
COUNT                           :COUNT(DISTINCT ?)                         :COUNT returns the number of rows returned by the query. You can use it as an aggregate or analytic function.
COUNT                           :COUNT(ALL ?)                         :COUNT returns the number of rows returned by the query. You can use it as an aggregate or analytic function.
COUNT                           :COUNT(*) OVER (analytic_clause)                        :COUNT returns the number of rows returned by the query. You can use it as an aggregate or analytic function.
COUNT                           :COUNT(DISTINCT ?) OVER (analytic_clause)                        :COUNT returns the number of rows returned by the query. You can use it as an aggregate or analytic function.
COUNT                           :COUNT(ALL ?) OVER (analytic_clause)                         :COUNT returns the number of rows returned by the query. You can use it as an aggregate or analytic function.
COVAR_POP                       :COVAR_POP(?,?)                                          :COVAR_POP returns the population covariance of a set of number pairs. You can use it as an aggregate or analytic function.
COVAR_POP                       :COVAR_POP(?,?) OVER(analytic_clause)                    :COVAR_POP returns the population covariance of a set of number pairs. You can use it as an aggregate or analytic function.
COVAR_SAMP                      :COVAR_SAMP(?,?)                                         :COVAR_SAMP returns the sample covariance of a set of number pairs. You can use it as an aggregate or analytic function.
COVAR_SAMP                      :COVAR_SAMP(?,?) OVER(analytic_clause)                   :COVAR_SAMP returns the sample covariance of a set of number pairs. You can use it as an aggregate or analytic function.
CUME_DIST                       :CUME_DIST(?...) WITHIN GROUP (ORDER BY ? ...)                                  :CUME_DIST calculates the cumulative distribution of a value in a group of values. The range of values returned by CUME_DIST is >0 to <=1. Tie values always evaluate to the same cumulative distribution value.
CUME_DIST                       :CUME_DIST(?...) WITHIN GROUP (ORDER BY ? ASC|DESC ...)                         :CUME_DIST calculates the cumulative distribution of a value in a group of values. The range of values returned by CUME_DIST is >0 to <=1. Tie values always evaluate to the same cumulative distribution value.
CUME_DIST                       :CUME_DIST(?...) WITHIN GROUP (ORDER BY ? NULLS FIRST|LAST...)                  :CUME_DIST calculates the cumulative distribution of a value in a group of values. The range of values returned by CUME_DIST is >0 to <=1. Tie values always evaluate to the same cumulative distribution value.
CUME_DIST                       :CUME_DIST(?...) WITHIN GROUP (ORDER BY ? ASC|DESC NULLS FIRST|LAST...)                :CUME_DIST calculates the cumulative distribution of a value in a group of values. The range of values returned by CUME_DIST is >0 to <=1. Tie values always evaluate to the same cumulative distribution value.
DENSE_RANK                      :DENSE_RANK(?...) WITHIN GROUP (ORDER BY ? ...)                                   :DENSE_RANK computes the rank of a row in an ordered group of rows and returns the rank as a NUMBER. The ranks are consecutive integers beginning with 1. The largest rank value is the number of unique values returned by the query. Rank values are not skipped in the event of ties. Rows with equal values for the ranking criteria receive the same rank. This function is useful for top-N and bottom-N reporting.
DENSE_RANK                      :DENSE_RANK(?...) WITHIN GROUP (ORDER BY ? ASC|DESC ...)                          :DENSE_RANK computes the rank of a row in an ordered group of rows and returns the rank as a NUMBER. The ranks are consecutive integers beginning with 1. The largest rank value is the number of unique values returned by the query. Rank values are not skipped in the event of ties. Rows with equal values for the ranking criteria receive the same rank. This function is useful for top-N and bottom-N reporting.
DENSE_RANK                      :DENSE_RANK(?...) WITHIN GROUP (ORDER BY ? NULLS FIRST|LAST...)                   :DENSE_RANK computes the rank of a row in an ordered group of rows and returns the rank as a NUMBER. The ranks are consecutive integers beginning with 1. The largest rank value is the number of unique values returned by the query. Rank values are not skipped in the event of ties. Rows with equal values for the ranking criteria receive the same rank. This function is useful for top-N and bottom-N reporting.
DENSE_RANK                      :DENSE_RANK(?...) WITHIN GROUP (ORDER BY ? ASC|DESC NULLS FIRST|LAST...)          :DENSE_RANK computes the rank of a row in an ordered group of rows and returns the rank as a NUMBER. The ranks are consecutive integers beginning with 1. The largest rank value is the number of unique values returned by the query. Rank values are not skipped in the event of ties. Rows with equal values for the ranking criteria receive the same rank. This function is useful for top-N and bottom-N reporting.
DENSE_RANK                      :DENSE_RANK() OVER (ORDER BY ? ...)                                   :DENSE_RANK computes the rank of a row in an ordered group of rows and returns the rank as a NUMBER. The ranks are consecutive integers beginning with 1. The largest rank value is the number of unique values returned by the query. Rank values are not skipped in the event of ties. Rows with equal values for the ranking criteria receive the same rank. This function is useful for top-N and bottom-N reporting.
DENSE_RANK                      :DENSE_RANK() OVER (query_partition_clause ORDER BY ? ...)                                   :DENSE_RANK computes the rank of a row in an ordered group of rows and returns the rank as a NUMBER. The ranks are consecutive integers beginning with 1. The largest rank value is the number of unique values returned by the query. Rank values are not skipped in the event of ties. Rows with equal values for the ranking criteria receive the same rank. This function is useful for top-N and bottom-N reporting.
FIRST                           :FIRST                         :FIRST and LAST are very similar functions. Both are aggregate and analytic functions that operate on a set of values from a set of rows that rank as the FIRST or LAST with respect to a given sorting specification. If only one row ranks as FIRST or LAST, then the aggregate operates on the set with only one element.
GROUP_ID                        :GROUP_ID()                      :GROUP_ID distinguishes duplicate groups resulting from a GROUP BY specification. It is useful in filtering out duplicate groupings from the query result. It returns an Oracle NUMBER to uniquely identify duplicate groups. This function is applicable only in a SELECT statement that contains a GROUP BY clause.
GROUPING                        :GROUPING(?)                      :GROUPING distinguishes superaggregate rows from regular grouped rows. GROUP BY extensions such as ROLLUP and CUBE produce superaggregate rows where the set of all values is represented by null. Using the GROUPING function, you can distinguish a null representing the set of all values in a superaggregate row from a null in a regular row.
GROUPING_ID                     :GROUPING_ID(?...)                   :GROUPING_ID returns a number corresponding to the GROUPING bit vector associated with a row. GROUPING_ID is applicable only in a SELECT statement that contains a GROUP BY extension, such as ROLLUP or CUBE, and a GROUPING function. In queries with many GROUP BY expressions, determining the GROUP BY level of a particular row requires many GROUPING functions, which leads to cumbersome SQL. GROUPING_ID is useful in these cases.
KURTOSIS_POP                    :KURTOSIS_POP(?)                  :The population kurtosis function KURTOSIS_POP is primarily used to determine the characteristics of outliers in a given distribution.
KURTOSIS_POP                    :KURTOSIS_POP(DISTINCT ?)                  :The population kurtosis function KURTOSIS_POP is primarily used to determine the characteristics of outliers in a given distribution.
KURTOSIS_POP                    :KURTOSIS_POP(ALL ?)                  :The population kurtosis function KURTOSIS_POP is primarily used to determine the characteristics of outliers in a given distribution.
KURTOSIS_POP                    :KURTOSIS_POP(UNIQUE ?)                  :The population kurtosis function KURTOSIS_POP is primarily used to determine the characteristics of outliers in a given distribution.
KURTOSIS_SAMP                   :KURTOSIS_SAMP(?)                 :The sample kurtosis function KURTOSIS_SAMP is primarily used to determine the characteristics of outliers in a given distribution.
KURTOSIS_SAMP                   :KURTOSIS_SAMP(DISTINCT ?)        :The sample kurtosis function KURTOSIS_SAMP is primarily used to determine the characteristics of outliers in a given distribution.
KURTOSIS_SAMP                   :KURTOSIS_SAMP(ALL ?)             :The sample kurtosis function KURTOSIS_SAMP is primarily used to determine the characteristics of outliers in a given distribution.
KURTOSIS_SAMP                   :KURTOSIS_SAMP(UNIQUE ?)          :The sample kurtosis function KURTOSIS_SAMP is primarily used to determine the characteristics of outliers in a given distribution.
LAST                            :LAST                          :FIRST and LAST are very similar functions. Both are aggregate and analytic functions that operate on a set of values from a set of rows that rank as the FIRST or LAST with respect to a given sorting specification. If only one row ranks as FIRST or LAST, then the aggregate operates on the set with only one element.
LISTAGG                         :LISTAGG([ALL|DISTINCT ]?[,'delimiter'][ listagg_overflow_clause])[ WITHIN GROUP (order_by_clause)[ OVER(query_partition_clause)]]                       :For a specified measure, LISTAGG orders data within each group specified in the ORDER BY clause and then concatenates the values of the measure column.
MAX                             :MAX(?)                                  :MAX returns maximum value of expr. You can use it as an aggregate or analytic function.
MAX                             :MAX(DISTINCT ?)                        :MAX returns maximum value of expr. You can use it as an aggregate or analytic function.
MAX                             :MAX(ALL ?)                             :MAX returns maximum value of expr. You can use it as an aggregate or analytic function.
MAX                             :MAX(?) OVER (analytic_clause)                                  :MAX returns maximum value of expr. You can use it as an aggregate or analytic function.
MAX                             :MAX(DISTINCT ?) OVER (analytic_clause)                        :MAX returns maximum value of expr. You can use it as an aggregate or analytic function.
MAX                             :MAX(ALL ?) OVER (analytic_clause)                             :MAX returns maximum value of expr. You can use it as an aggregate or analytic function.
MEDIAN                          :MEDIAN(?)                        :MEDIAN is an inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns the middle value or an interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.
MEDIAN                          :MEDIAN(?) OVER()                       :MEDIAN is an inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns the middle value or an interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.
MEDIAN                          :MEDIAN(?) OVER(query_partition_clause)                       :MEDIAN is an inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns the middle value or an interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.
MIN                             :MIN(?)                                     :MIN returns maximum value of expr. You can use it as an aggregate or analytic function.
MIN                             :MIN(DISTINCT ?)                            :MIN returns maximum value of expr. You can use it as an aggregate or analytic function.
MIN                             :MIN(ALL ?)                                 :MIN returns maximum value of expr. You can use it as an aggregate or analytic function.
MIN                             :MIN(?) OVER (analytic_clause)              :MIN returns maximum value of expr. You can use it as an aggregate or analytic function.
MIN                             :MIN(DISTINCT ?) OVER (analytic_clause)     :MIN returns maximum value of expr. You can use it as an aggregate or analytic function.
MIN                             :MIN(ALL ?) OVER (analytic_clause)          :MIN returns maximum value of expr. You can use it as an aggregate or analytic function.
PERCENT_RANK                    :PERCENT_RANK(?...) WITHIN GROUP (ORDER BY ? ...)                                  :PERCENT_RANK is similar to the CUME_DIST (cumulative distribution) function. The range of values returned by PERCENT_RANK is 0 to 1, inclusive. The first row in any set has a PERCENT_RANK of 0. The return value is NUMBER.
PERCENT_RANK                    :PERCENT_RANK(?...) WITHIN GROUP (ORDER BY ? ASC|DESC ...)                         :PERCENT_RANK is similar to the CUME_DIST (cumulative distribution) function. The range of values returned by PERCENT_RANK is 0 to 1, inclusive. The first row in any set has a PERCENT_RANK of 0. The return value is NUMBER.
PERCENT_RANK                    :PERCENT_RANK(?...) WITHIN GROUP (ORDER BY ? NULLS FIRST|LAST...)                  :PERCENT_RANK is similar to the CUME_DIST (cumulative distribution) function. The range of values returned by PERCENT_RANK is 0 to 1, inclusive. The first row in any set has a PERCENT_RANK of 0. The return value is NUMBER.
PERCENT_RANK                    :PERCENT_RANK(?...) WITHIN GROUP (ORDER BY ? ASC|DESC NULLS FIRST|LAST...)         :PERCENT_RANK is similar to the CUME_DIST (cumulative distribution) function. The range of values returned by PERCENT_RANK is 0 to 1, inclusive. The first row in any set has a PERCENT_RANK of 0. The return value is NUMBER.
PERCENTILE_CONT                 :PERCENTILE_CONT(?) WITHIN GROUP (ORDER BY ? )                                                  :PERCENTILE_CONT is an inverse distribution function that assumes a continuous distribution model. It takes a percentile value and a sort specification, and returns an interpolated value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation.
PERCENTILE_CONT                 :PERCENTILE_CONT(?) WITHIN GROUP (ORDER BY ? ASC|DESC)                                          :PERCENTILE_CONT is an inverse distribution function that assumes a continuous distribution model. It takes a percentile value and a sort specification, and returns an interpolated value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation.
PERCENTILE_CONT                 :PERCENTILE_CONT(?) WITHIN GROUP (ORDER BY ? ) OVER (query_partition_clause)                    :PERCENTILE_CONT is an inverse distribution function that assumes a continuous distribution model. It takes a percentile value and a sort specification, and returns an interpolated value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation.
PERCENTILE_CONT                 :PERCENTILE_CONT(?) WITHIN GROUP (ORDER BY ? ASC|DESC) OVER (query_partition_clause)            :PERCENTILE_CONT is an inverse distribution function that assumes a continuous distribution model. It takes a percentile value and a sort specification, and returns an interpolated value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation.
PERCENTILE_DISC                 :PERCENTILE_DISC(?) WITHIN GROUP (ORDER BY ? )                                                  :PERCENTILE_DISC is an inverse distribution function that assumes a discrete distribution model. It takes a percentile value and a sort specification and returns an element from the set. Nulls are ignored in the calculation.
PERCENTILE_DISC                 :PERCENTILE_DISC(?) WITHIN GROUP (ORDER BY ? ASC|DESC)                                          :PERCENTILE_DISC is an inverse distribution function that assumes a discrete distribution model. It takes a percentile value and a sort specification and returns an element from the set. Nulls are ignored in the calculation.
PERCENTILE_DISC                 :PERCENTILE_DISC(?) WITHIN GROUP (ORDER BY ? ) OVER (query_partition_clause)                    :PERCENTILE_DISC is an inverse distribution function that assumes a discrete distribution model. It takes a percentile value and a sort specification and returns an element from the set. Nulls are ignored in the calculation.
PERCENTILE_DISC                 :PERCENTILE_DISC(?) WITHIN GROUP (ORDER BY ? ASC|DESC) OVER (query_partition_clause)            :PERCENTILE_DISC is an inverse distribution function that assumes a discrete distribution model. It takes a percentile value and a sort specification and returns an element from the set. Nulls are ignored in the calculation.
RANK                            :RANK(?...) WITHIN GROUP (ORDER BY ? ...)                                  :RANK calculates the rank of a value in a group of values. The return type is NUMBER.
RANK                            :RANK(?...) WITHIN GROUP (ORDER BY ? ASC|DESC ...)                         :RANK calculates the rank of a value in a group of values. The return type is NUMBER.
RANK                            :RANK(?...) WITHIN GROUP (ORDER BY ? NULLS FIRST|LAST...)                  :RANK calculates the rank of a value in a group of values. The return type is NUMBER.
RANK                            :RANK(?...) WITHIN GROUP (ORDER BY ? ASC|DESC NULLS FIRST|LAST...)         :RANK calculates the rank of a value in a group of values. The return type is NUMBER.
REGR_SLOPE                      :REGR_SLOPE(?,?)                                          :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_SLOPE                      :REGR_SLOPE(?,?) OVER(analytic_clause)                    :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_INTERCEPT                  :REGR_INTERCEPT(?,?)                                          :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_INTERCEPT                  :REGR_INTERCEPT(?,?) OVER(analytic_clause)                    :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_COUNT                      :REGR_COUNT(?,?)                                          :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_COUNT                      :REGR_COUNT(?,?) OVER(analytic_clause)                    :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_R2                         :REGR_R2(?,?)                                          :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_R2                         :REGR_R2(?,?) OVER(analytic_clause)                    :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_AVGX                       :REGR_AVGX(?,?)                                          :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_AVGX                       :REGR_AVGX(?,?) OVER(analytic_clause)                    :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_AVGY                       :REGR_AVGY(?,?)                                          :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_AVGY                       :REGR_AVGY(?,?) OVER(analytic_clause)                    :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_SXX                        :REGR_SXX(?,?)                                          :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_SXX                        :REGR_SXX(?,?) OVER(analytic_clause)                    :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_SYY                        :REGR_SYY(?,?)                                          :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_SYY                        :REGR_SYY(?,?) OVER(analytic_clause)                    :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_SXY                        :REGR_SXY(?,?)                                          :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
REGR_SXY                        :REGR_SXY(?,?) OVER(analytic_clause)                    :The linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions.
SKEWNESS_POP                    :SKEWNESS_POP(?)                :SKEWNESS_POP is an aggregate function that is primarily used to determine symmetry in a given distribution.
SKEWNESS_POP                    :SKEWNESS_POP(DISTINCT ?)       :SKEWNESS_POP is an aggregate function that is primarily used to determine symmetry in a given distribution.
SKEWNESS_POP                    :SKEWNESS_POP(ALL ?)            :SKEWNESS_POP is an aggregate function that is primarily used to determine symmetry in a given distribution.
SKEWNESS_POP                    :SKEWNESS_POP(UNIQUE ?)         :SKEWNESS_POP is an aggregate function that is primarily used to determine symmetry in a given distribution.
SKEWNESS_SAMP                   :SKEWNESS_SAMP(?)                :SKEWNESS_SAMP is an aggregate function that is primarily used to determine symmetry in a given distribution.
SKEWNESS_SAMP                   :SKEWNESS_SAMP(DISTINCT ?)       :SKEWNESS_SAMP is an aggregate function that is primarily used to determine symmetry in a given distribution.
SKEWNESS_SAMP                   :SKEWNESS_SAMP(ALL ?)            :SKEWNESS_SAMP is an aggregate function that is primarily used to determine symmetry in a given distribution.
SKEWNESS_SAMP                   :SKEWNESS_SAMP(UNIQUE ?)         :SKEWNESS_SAMP is an aggregate function that is primarily used to determine symmetry in a given distribution.
STATS_BINOMIAL_TEST             :STATS_BINOMIAL_TEST(?,?,p)           :STATS_BINOMIAL_TEST is an exact probability test used for dichotomous variables, where only two possible values exist. It tests the difference between a sample proportion and a given proportion. The sample size in such tests is usually small.
STATS_BINOMIAL_TEST             :STATS_BINOMIAL_TEST(?,?,p,'TWO_SIDED_PROB')           :STATS_BINOMIAL_TEST is an exact probability test used for dichotomous variables, where only two possible values exist. It tests the difference between a sample proportion and a given proportion. The sample size in such tests is usually small.
STATS_BINOMIAL_TEST             :STATS_BINOMIAL_TEST(?,?,p,'EXACT_PROB')           :STATS_BINOMIAL_TEST is an exact probability test used for dichotomous variables, where only two possible values exist. It tests the difference between a sample proportion and a given proportion. The sample size in such tests is usually small.
STATS_BINOMIAL_TEST             :STATS_BINOMIAL_TEST(?,?,p,'ONE_SIDED_PROB_OR_MORE')           :STATS_BINOMIAL_TEST is an exact probability test used for dichotomous variables, where only two possible values exist. It tests the difference between a sample proportion and a given proportion. The sample size in such tests is usually small.
STATS_BINOMIAL_TEST             :STATS_BINOMIAL_TEST(?,?,p,'ONE_SIDED_PROB_OR_LESS')           :STATS_BINOMIAL_TEST is an exact probability test used for dichotomous variables, where only two possible values exist. It tests the difference between a sample proportion and a given proportion. The sample size in such tests is usually small.
STATS_CROSSTAB                  :STATS_CROSSTAB(?,?[,'CHISQ_OBS'|'CHISQ_SIG'|'CHISQ_DF'|'PHI_COEFFICIENT'|'CRAMERS_V'|'CONT_COEFFICIENT'|'COHENS_K')                :Crosstabulation (commonly called crosstab) is a method used to analyze two nominal variables. The STATS_CROSSTAB function takes two required arguments: expr1 and expr2 are the two variables being analyzed. The optional third argument lets you specify the meaning of the NUMBER value returned by this function, as shown in Table 7-4. For this argument, you can specify a text literal, or a bind variable or expression that evaluates to a constant character value. If you omit the third argument, then the default is 'CHISQ_SIG'.
STATS_F_TEST                    :STATS_F_TEST(?,?)                  :STATS_F_TEST tests whether two variances are significantly different. The observed value of f is the ratio of one variance to the other, so values very different from 1 usually indicate significant differences.
STATS_F_TEST                    :STATS_F_TEST(?,?[,{'STATISTIC'|'DF_NUM'|'DF_DEN'|'ONE_SIDED_SIG',?}|'TWO_SIDED_SIG'])                  :STATS_F_TEST tests whether two variances are significantly different. The observed value of f is the ratio of one variance to the other, so values very different from 1 usually indicate significant differences.
STATS_KS_TEST                   :STATS_KS_TEST(?,?)                 :STATS_KS_TEST is a Kolmogorov-Smirnov function that compares two samples to test whether they are from the same population or from populations that have the same distribution. It does not assume that the population from which the samples were taken is normally distributed.
STATS_KS_TEST                   :STATS_KS_TEST(?,?,'STATISTIC')                 :STATS_KS_TEST is a Kolmogorov-Smirnov function that compares two samples to test whether they are from the same population or from populations that have the same distribution. It does not assume that the population from which the samples were taken is normally distributed.
STATS_KS_TEST                   :STATS_KS_TEST(?,?,'SIG')                 :STATS_KS_TEST is a Kolmogorov-Smirnov function that compares two samples to test whether they are from the same population or from populations that have the same distribution. It does not assume that the population from which the samples were taken is normally distributed.
STATS_MODE                      :STATS_MODE(?)                    :STATS_MODE takes as its argument a set of values and returns the value that occurs with the greatest frequency. If more than one mode exists, then Oracle Database chooses one and returns only that one value.
STATS_MW_TEST                   :STATS_MW_TEST(?,?)                 :A Mann Whitney test compares two independent samples to test the null hypothesis that two populations have the same distribution function against the alternative hypothesis that the two distribution functions are different.
STATS_MW_TEST                   :STATS_MW_TEST(?,?[,'STATISTIC'|'U_STATISTIC'|'ONE_SIDED_SIG'|'TWO_SIDED_SIG'])                 :A Mann Whitney test compares two independent samples to test the null hypothesis that two populations have the same distribution function against the alternative hypothesis that the two distribution functions are different.
ATS_ONE_WAY_ANOVA               :STATS_ONE_WAY_ANOVA(?,?[,'SUM_SQUARES_BETEEN'|'SUM_SQUARES_WITHIN'|â€™DF_BETWEEN'|'DF_WITHIN'|'MEAN_SQUARES_BETWEEN'|'MEAN_SQUARES_WITHIN'|'F_RATIO'|'SIG'])           :The one-way analysis of variance function (STATS_ONE_WAY_ANOVA) tests differences in means (for groups or variables) for statistical significance by comparing two different estimates of variance. One estimate is based on the variances within each group or category. This is known as the mean squares within or mean square error. The other estimate is based on the variances among the means of the groups. This is known as the mean squares between. If the means of the groups are significantly different, then the mean squares between will be larger than expected and will not match the mean squares within. If the mean squares of the groups are consistent, then the two variance estimates will be about the same.
STATS_WSR_TEST                  :STATS_WSR_TEST(?,?[,'STATISTIC'|'ONE_SIDED_SIG'|'TWO_SIDED_SIG'])                :STATS_WSR_TEST is a Wilcoxon Signed Ranks test of paired samples to determine whether the median of the differences between the samples is significantly different from zero. The absolute values of the differences are ordered and assigned ranks. Then the null hypothesis states that the sum of the ranks of the positive differences is equal to the sum of the ranks of the negative differences.
STDDEV                          :STDDEV(?)                                      :STDDEV returns the sample standard deviation of expr, a set of numbers. You can use it as both an aggregate and analytic function. It differs from STDDEV_SAMP in that STDDEV returns zero when it has only 1 row of input data, whereas STDDEV_SAMP returns null.
STDDEV                          :STDDEV(DISTINCT ?)                             :STDDEV returns the sample standard deviation of expr, a set of numbers. You can use it as both an aggregate and analytic function. It differs from STDDEV_SAMP in that STDDEV returns zero when it has only 1 row of input data, whereas STDDEV_SAMP returns null.
STDDEV                          :STDDEV(ALL ?)                                  :STDDEV returns the sample standard deviation of expr, a set of numbers. You can use it as both an aggregate and analytic function. It differs from STDDEV_SAMP in that STDDEV returns zero when it has only 1 row of input data, whereas STDDEV_SAMP returns null.
STDDEV                          :STDDEV(?) OVER (analytic_clause)               :STDDEV returns the sample standard deviation of expr, a set of numbers. You can use it as both an aggregate and analytic function. It differs from STDDEV_SAMP in that STDDEV returns zero when it has only 1 row of input data, whereas STDDEV_SAMP returns null.
STDDEV                          :STDDEV(DISTINCT ?) OVER (analytic_clause)      :STDDEV returns the sample standard deviation of expr, a set of numbers. You can use it as both an aggregate and analytic function. It differs from STDDEV_SAMP in that STDDEV returns zero when it has only 1 row of input data, whereas STDDEV_SAMP returns null.
STDDEV                          :STDDEV(ALL ?) OVER (analytic_clause)           :STDDEV returns the sample standard deviation of expr, a set of numbers. You can use it as both an aggregate and analytic function. It differs from STDDEV_SAMP in that STDDEV returns zero when it has only 1 row of input data, whereas STDDEV_SAMP returns null.
STDDEV_POP                      :STDDEV_POP(?)                                  :STDDEV_POP computes the population standard deviation and returns the square root of the population variance. You can use it as both an aggregate and analytic function.
STDDEV_POP                      :STDDEV_POP(?) OVER (analytic_clause)           :STDDEV_POP computes the population standard deviation and returns the square root of the population variance. You can use it as both an aggregate and analytic function.
STDDEV_SAMP                     :STDDEV_SAMP(?)                                 :STDDEV_SAMP computes the cumulative sample standard deviation and returns the square root of the sample variance. You can use it as both an aggregate and analytic function.
STDDEV_SAMP                     :STDDEV_SAMP(?) OVER (analytic_clause)          :STDDEV_SAMP computes the cumulative sample standard deviation and returns the square root of the sample variance. You can use it as both an aggregate and analytic function.
SUM                             :SUM(?)                                        :SUM returns the sum of values of expr. You can use it as an aggregate or analytic function.
SUM                             :SUM(DISTINCT ?)                               :SUM returns the sum of values of expr. You can use it as an aggregate or analytic function.
SUM                             :SUM(ALL ?)                                    :SUM returns the sum of values of expr. You can use it as an aggregate or analytic function.
SUM                             :SUM(?) OVER (analytic_clause)                 :SUM returns the sum of values of expr. You can use it as an aggregate or analytic function.
SUM                             :SUM(DISTINCT ?) OVER (analytic_clause)        :SUM returns the sum of values of expr. You can use it as an aggregate or analytic function.
SUM                             :SUM(ALL ?) OVER (analytic_clause)             :SUM returns the sum of values of expr. You can use it as an aggregate or analytic function.
SYS_OP_ZONE_ID                  :SYS_OP_ZONE_ID(?)                                      :SYS_OP_ZONE_ID takes as its argument a rowid and returns a zone ID. The rowid identifies a row in a table. The zone ID identifies the set of contiguous disk blocks, called the zone, that contains the row. The function returns a NUMBER value.
SYS_OP_ZONE_ID                  :SYS_OP_ZONE_ID(schema.table.rowid,scale)               :SYS_OP_ZONE_ID takes as its argument a rowid and returns a zone ID. The rowid identifies a row in a table. The zone ID identifies the set of contiguous disk blocks, called the zone, that contains the row. The function returns a NUMBER value.
SYS_OP_ZONE_ID                  :SYS_OP_ZONE_ID(t_alias.rowid[,scale])                  :SYS_OP_ZONE_ID takes as its argument a rowid and returns a zone ID. The rowid identifies a row in a table. The zone ID identifies the set of contiguous disk blocks, called the zone, that contains the row. The function returns a NUMBER value.
SYS_XMLAGG                      :SYS_XMLAGG(?)                                  :SYS_XMLAgg aggregates all of the XML documents or fragments represented by expr and produces a single XML document. It adds a new enclosing element with a default name ROWSET. If you want to format the XML document differently, then specify fmt, which is an instance of the XMLFormat object.
SYS_XMLAGG                      :SYS_XMLAGG(?,fmt)                              :SYS_XMLAgg aggregates all of the XML documents or fragments represented by expr and produces a single XML document. It adds a new enclosing element with a default name ROWSET. If you want to format the XML document differently, then specify fmt, which is an instance of the XMLFormat object.
TO_APPROX_COUNT_DISTINCT        :TO_APPROX_COUNT_DISTINCT(?)                        :TO_APPROX_COUNT_DISTINCT takes as its input a detail containing information about an approximate distinct value count, and converts it to a NUMBER value.
TO_APPROX_PERCENTILE            :TO_APPROX_PERCENTILE(detail,expr,'datatype'[,'DESC'|'ASC'|'ERROR_RATE'|'CONFIDENCE'])          :TO_APPROX_PERCENTILE takes as its input a detail containing approximate percentile information, a percentile value, and a sort specification, and returns an approximate interpolated value that would fall into that percentile value with respect to the sort specification.
VAR_POP                         :VAR_POP(?)                                         :VAR_POP returns the population variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function.
VAR_POP                         :VAR_POP(?) OVER (analytic_clause)                  :VAR_POP returns the population variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function.
VAR_SAMP                        :VAR_SAMP(?)                                        :VAR_SAMP returns the sample variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function.
VAR_SAMP                        :VAR_SAMP(?) OVER (analytic_clause)                 :VAR_SAMP returns the sample variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function.
VARIANCE                        :VARIANCE(?)                                        :VARIANCE returns the variance of expr. You can use it as an aggregate or analytic function.
VARIANCE                        :VARIANCE(DISTINCT ?)                               :VARIANCE returns the variance of expr. You can use it as an aggregate or analytic function.
VARIANCE                        :VARIANCE(ALL ?)                                    :VARIANCE returns the variance of expr. You can use it as an aggregate or analytic function.
VARIANCE                        :VARIANCE(?) OVER (analytic_clause)                 :VARIANCE returns the variance of expr. You can use it as an aggregate or analytic function.
VARIANCE                        :VARIANCE(DISTINCT ?) OVER (analytic_clause)        :VARIANCE returns the variance of expr. You can use it as an aggregate or analytic function.
VARIANCE                        :VARIANCE(ALL ?) OVER (analytic_clause)             :VARIANCE returns the variance of expr. You can use it as an aggregate or analytic function.
XMLAGG                          :XMLAGG(XML_Type_instance[,order_by_clause])        :XMLAgg is an aggregate function. It takes a collection of XML fragments and returns an aggregated XML document. Any arguments that return null are dropped from the result.
[Analytic Functions]
analytic_function               :analytic_function([arguments]) OVER window_name|(analytic_clause)    :Analytic functions are commonly used to compute cumulative, moving, centered, and reporting aggregates.
analytic_clause                 :[window_name|query_partition_clause][ order_by_clause[ windowing_clause]]           :Use OVER analytic_clause to indicate that the function operates on a query result set. This clause is computed after the FROM, WHERE, GROUP BY, and HAVING clauses. You can specify analytic functions with this clause in the select list or ORDER BY clause. To filter the results of a query based on an analytic function, nest these functions within the parent query, and then filter the results of the nested subquery.
query_partition_clause          :PARTITION BY expr...|(expr...)   :To use the query_partition_clause in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the model_column_clauses) or a partitioned outer join (in the outer_join_clause), use the lower branch of the syntax (with parentheses).
order_by_clause                 :ORDER[ SIBLINGS] BY {expr|position|c_alias[ ASC|DESC][ NULLS FIRST|NULLS LAST]}       :Use the order_by_clause to specify how data is ordered within a partition. For all analytic functions you can order the values in a partition on multiple keys, each defined by a value_expr and each qualified by an ordering sequence.
windowing_clause                :ROWS|RANGE|GROUPS {BETWEEN {UNBOUNDED PRECEDING}|{CURRENT ROW}|{value_expr PRECEDING|FOLLOWING} AND  }|{{UNBOUNDED PRECEDING}|{CURRENT ROW}|{value_expr PRECEDING|FOLLOWING}}[ EXCLUDE {CURRENT ROW|GROUPS|TIES|NO OTHERS}]       :Some analytic functions allow the windowing_clause. In the listing of analytic functions at the end of this section, the functions that allow the windowing_clause are followed by an asterisk (*).
[Object Reference Functions]
DEREF                       :DEREF(expr)            :DEREF returns the object reference of argument expr, where expr must return a REF to an object. If you do not use this function in a query, then Oracle Database returns the object ID of the REF instead, as shown in the example that follows.
MAKE_REF                    :MAKE_REF(table|view,key...)         :MAKE_REF creates a REF to a row of an object view or a row in an object table whose object identifier is primary key based. This function is useful, for example, if you are creating an object view
REF                         :REF(correlation_variable)           :REF takes as its argument a correlation variable (table alias) associated with a row of an object table or an object view. A REF value is returned for the object instance that is bound to the variable or row.
REFTOHEX                    :REFTOHEX(?)         :REFTOHEX converts argument expr to a character value containing its hexadecimal equivalent. expr must return a REF.
VALUE                       :VALUE(correlation_variable)            :VALUE takes as its argument a correlation variable (table alias) associated with a row of an object table and returns object instances stored in the object table. The type of the object instances is the same type as the object table.
[Model Functions]
CV                          :CV([dimension_column])                  :The CV function can be used only in the model_clause of a SELECT statement and then only on the right-hand side of a model rule. It returns the current value of a dimension column or a partitioning column carried from the left-hand side to the right-hand side of a rule. This function is used in the model_clause to provide relative indexing with respect to the dimension column. The return type is that of the data type of the dimension column. If you omit the argument, then it defaults to the dimension column associated with the relative position of the function within the cell reference.
ITERATION_NUMBER            :ITERATION_NUMBER    :The ITERATION_NUMBER function can be used only in the model_clause of the SELECT statement and then only when ITERATE(number) is specified in the model_rules_clause. It returns an integer representing the completed iteration through the model rules. The ITERATION_NUMBER function returns 0 during the first iteration. For each subsequent iteration, the ITERATION_NUMBER function returns the equivalent of iteration_number plus one.
PRESENTNNV                  :PRESENTNNV(cell_reference ,expr1,expr2)          :The PRESENTNNV function can be used only in the model_clause of the SELECT statement and then only on the right-hand side of a model rule. It returns expr1 when cell_reference exists prior to the execution of the model_clause and is not null when PRESENTNNV is evaluated. Otherwise it returns expr2. This function differs from NVL2 in that NVL2 evaluates the data at the time it is executed, rather than evaluating the data as it was prior to the execution of the model_clause.
PRESENTV                    :PRESENTV(cell_reference ,expr1,expr2)            :The PRESENTV function can be used only within the model_clause of the SELECT statement and then only on the right-hand side of a model rule. It returns expr1 when, prior to the execution of the model_clause, cell_reference exists. Otherwise it returns expr2.
PREVIOUS                    :PREVIOUS(cell_reference)            :The PREVIOUS function can be used only in the model_clause of the SELECT statement and then only in the ITERATE ... [ UNTIL ] clause of the model_rules_clause. It returns the value of cell_reference at the beginning of each iteration.
[OLAP Functions]
CUBE_TABLE                  :CUBE_TABLE('schema.cub[ {HIERARCHY|HRR dimension hierarchy}...]')       :CUBE_TABLE extracts data from a cube or dimension and returns it in the two-dimensional format of a relational table, which can be used by SQL-based applications.
CUBE_TABLE                  :CUBE_TABLE('schema.dimension[ HIERARCHY|HRR [ dimension ]hierarchy}]')       :CUBE_TABLE extracts data from a cube or dimension and returns it in the two-dimensional format of a relational table, which can be used by SQL-based applications.
[Data Cartridge Functions]
DATAOBJ_TO_MAT_PARTITION    :DATAOBJ_TO_MAT_PARTITION(table,partition_id)     :DATAOBJ_TO_MAT_PARTITION is useful only to Data Cartridge developers who are performing data maintenance or query operations on system-partitioned tables that are used to store domain index data. The DML or query operations are triggered by corresponding operations on the base table of the domain index.
DATAOBJ_TO_PARTITION        :DATAOBJ_TO_PARTITION(table,partition_id)         :DATAOBJ_TO_PARTITION is useful only to Data Cartridge developers who are performing data maintenance or query operations on system-partitioned tables that are used to store domain index data. The DML or query operations are triggered by corresponding operations on the base table of the domain index.